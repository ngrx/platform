# V20 Update Guide

## Angular CLI update

NgRx supports using the Angular CLI `ng update` command to update your dependencies. Migration schematics are run to make the upgrade smoother. These schematics will fix some of the breaking changes.

To update your packages to the latest released version, run the command below.

```sh
# NgRx Store related packages
ng update @ngrx/store@20.0.0-beta.0

# NgRx Signals package
ng update @ngrx/signals@20.0.0-beta.0
```

## Dependencies

Version 20 has the minimum version requirements:

- Angular version 20.x
- Angular CLI version 20.x
- TypeScript version 5.8.x
- RxJS version ^6.5.x || ^7.5.0

## Breaking changes

### Signals

##### `STATE_SOURCE` is a `DeepSignal`

Given the following type definition:

```ts
type User = {
  firstname: string;
  lastname: string;
};
```

BEFORE:

```ts
STATE_SOURCE: WritableSignal<User>;
```

AFTER:

```ts
STATE_SOURCE: {
  firstname: WritableSignal<string>;
  lastname: WritableSignal<string>;
};
```

##### Different object reference

The returned object from `signalState()` or `getState()` no longer keeps the same object identity:

```ts
const obj = { ngrx: 'rocks' };
const state = signalState(obj);
```

BEFORE:

```ts
state() === obj; // ‚úÖ true
```

AFTER:

```ts
state() === obj; // ‚ùå false
```


##### No signal change on empty patch

Empty patches no longer emit updates, since no signal is mutated.

Given:

```ts
const state = signalState({ ngrx: 'rocks' });

let count = 0;
effect(() => count++);

TestBed.flushEffects();
expect(count).toBe(1);

patchState(state, {});
```

BEFORE:

```ts
expect(count).toBe(2); // triggered
```

AFTER:

```ts
expect(count).toBe(1); // no update
```

##### No wrapping of top-level `WritableSignal`s

Given:

```ts
const Store = signalStore(
  withState({ foo: signal('bar') })
);
const store = new Store();
```

BEFORE:

```ts
store.foo; // Signal<Signal<string>>
```

AFTER:

```ts
store.foo; // Signal<string>
```

##### `patchState` no longer supports `Record` as root state

Using a `Record` as the root state is no longer supported by `patchState`.

BEFORE:

```ts
const Store = signalStore(
  { providedIn: 'root' },
  withState<Record<number, number>>({}),
  withMethods((store) => ({
    addNumber(num: number): void {
      patchState(store, {
        [num]: num,
      });
    },
  }))
);

store.addNumber(1);
store.addNumber(2);

expect(getState(store)).toEqual({ 1: 1, 2: 2 });
```

AFTER:

```ts
const Store = signalStore(
  { providedIn: 'root' },
  withState<Record<number, number>>({}),
  withMethods((store) => ({
    addNumber(num: number): void {
      patchState(store, {
        [num]: num,
      });
    },
  }))
);

store.addNumber(1);
store.addNumber(2);

expect(getState(store)).toEqual({}); // ‚ùå Nothing updated
```

If dynamic keys are needed, consider managing them inside a nested signal instead.

### Entity

#### `getInitialState` is type-safe

`getInitialState` is now type-safe, meaning that the initial state must match the entity state type. This change ensures that the initial state is correctly typed and prevents additional properties from being added to the state.

BEFORE:

```ts
import { EntityState, createEntityAdapter, EntityAdapter } from '@ngrx/entity';

interface Book {
  id: string;
  title: string;
}
interface BookState extends EntityState<Book> {
  selectedBookId: string | null;
}

export const adapter: EntityAdapter<Book> = createEntityAdapter<Book>();
export const initialState: BookState = adapter.getInitialState({
  selectedBookId: '1',
  otherProperty: 'value',
});
```

AFTER:

```ts

import { EntityState, createEntityAdapter, EntityAdapter } from '@ngrx/entity';

interface Book {
  id: string;
  title: string;
}
interface BookState extends EntityState<Book> {
  selectedBookId: string | null;
}

export const adapter: EntityAdapter<Book> = createEntityAdapter<Book>();
export const initialState: BookState = adapter.getInitialState({
  selectedBookId: '1',
  // üëá this throws an error
  // otherProperty: 'value',
});
```

### Effects

#### `act` operator is removed

The `act` operator is removed in favor of core RxJS flattening operators and `mapResponse` from the `@ngrx/operators` package.

BEFORE:

```ts
@Injectable()
export class AuthEffects {
  readonly login$ = createEffect(() => {
    return this.actions$.pipe(
      ofType(LoginPageActions.loginFormSubmitted),
      act({
        project: ({ credentials }) =>
          this.authService
            .login(credentials)
            .pipe(map((user) => AuthApiActions.loginSuccess({ user }))),
        error: (error) => AuthApiActions.loginFailure({ error }),
        operator: exhaustMap,
      })
    );
  });
}
```

AFTER:

```ts
@Injectable()
export class AuthEffects {
  readonly login$ = createEffect(() => {
    return this.actions$.pipe(
      ofType(LoginPageActions.loginFormSubmitted),
      exhaustMap(({ credentials }) =>
        this.authService.login(credentials).pipe(
          mapResponse({
            next: (user) => AuthApiActions.loginSuccess({ user }),
            error: (error) => AuthApiActions.loginFailure({ error }),
          })
        )
      )
    );
  });
}
```
