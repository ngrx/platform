
    <html>
    <head>
      <script src="https://unpkg.com/@stackblitz/sdk/bundles/sdk.umd.js"></script>
    </head>
    <body>
    <script>
      const project = {
        files: {"angular.json":"{  \"$schema\":    \"./node_modules/@angular-devkit/core/src/workspace/workspace-schema.json\",  \"version\": 1,  \"newProjectRoot\": \"projects\",  \"defaultProject\": \"example-app\",  \"projects\": {    \"example-app\": {      \"root\": \"\",      \"sourceRoot\": \"projects/example-app/src\",      \"projectType\": \"application\",      \"prefix\": \"bc\",      \"schematics\": {},      \"architect\": {        \"build\": {          \"builder\": \"@angular-devkit/build-angular:browser\",          \"options\": {            \"outputPath\": \"projects/example-app/dist\",            \"index\": \"projects/example-app/src/index.html\",            \"main\": \"projects/example-app/src/main.ts\",            \"polyfills\": \"projects/example-app/src/polyfills.ts\",            \"tsConfig\": \"projects/example-app/tsconfig.app.json\",            \"assets\": [              \"projects/example-app/src/favicon.ico\",              \"projects/example-app/src/assets\"            ],            \"styles\": [\"projects/example-app/src/styles.css\"],            \"scripts\": []          },          \"configurations\": {            \"production\": {              \"fileReplacements\": [                {                  \"replace\":                    \"projects/example-app/src/environments/environment.ts\",                  \"with\":                    \"projects/example-app/src/environments/environment.prod.ts\"                }              ],              \"optimization\": true,              \"outputHashing\": \"all\",              \"sourceMap\": false,              \"extractCss\": true,              \"namedChunks\": false,              \"aot\": true,              \"extractLicenses\": true,              \"vendorChunk\": false,              \"buildOptimizer\": true            }          }        },        \"serve\": {          \"builder\": \"@angular-devkit/build-angular:dev-server\",          \"options\": {            \"browserTarget\": \"example-app:build\"          },          \"configurations\": {            \"production\": {              \"browserTarget\": \"example-app:build:production\"            }          }        },        \"extract-i18n\": {          \"builder\": \"@angular-devkit/build-angular:extract-i18n\",          \"options\": {            \"browserTarget\": \"example-app:build\"          }        },        \"test\": {          \"builder\": \"@angular-devkit/build-angular:karma\",          \"options\": {            \"main\": \"projects/example-app/src/test.ts\",            \"polyfills\": \"projects/example-app/src/polyfills.ts\",            \"tsConfig\": \"projects/example-app/tsconfig.spec.json\",            \"karmaConfig\": \"projects/example-app/karma.conf.js\",            \"styles\": [\"projects/example-app/src/styles.css\"],            \"scripts\": [],            \"assets\": [              \"projects/example-app/src/favicon.ico\",              \"projects/example-app/src/assets\"            ]          }        },        \"lint\": {          \"builder\": \"@angular-devkit/build-angular:tslint\",          \"options\": {            \"tsConfig\": [              \"projects/example-app/tsconfig.app.json\",              \"projects/example-app/tsconfig.spec.json\"            ],            \"exclude\": [\"**/node_modules/**\"]          }        }      }    },    \"example-app-e2e\": {      \"root\": \"projects/example-app-e2e/\",      \"projectType\": \"application\",      \"architect\": {        \"e2e\": {          \"builder\": \"@angular-devkit/build-angular:protractor\",          \"options\": {            \"protractorConfig\": \"projects/example-app-e2e/protractor.conf.js\",            \"devServerTarget\": \"example-app:serve\"          },          \"configurations\": {            \"production\": {              \"devServerTarget\": \"example-app:serve:production\"            }          }        },        \"lint\": {          \"builder\": \"@angular-devkit/build-angular:tslint\",          \"options\": {            \"tsConfig\": \"projects/example-app-e2e/tsconfig.e2e.json\",            \"exclude\": [\"**/node_modules/**\"]          }        }      }    }  },  \"schematics\": {    \"@schematics/angular:component\": {      \"inlineStyle\": true,      \"inlineTemplate\": true,      \"flat\": true,      \"spec\": false,      \"prefix\": \"bc\",      \"styleext\": \"css\"    },    \"@schematics/angular:directive\": {      \"prefix\": \"bc\"    }  }}","projects/example-app/src/app/app-routing.module.ts":"import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';import { AuthGuard } from './auth/services/auth-guard.service';import { NotFoundPageComponent } from './core/containers/not-found-page.component';export const routes: Routes = [  { path: '', redirectTo: '/books', pathMatch: 'full' },  {    path: 'books',    loadChildren: './books/books.module#BooksModule',    canActivate: [AuthGuard],  },  { path: '**', component: NotFoundPageComponent },];@NgModule({  imports: [RouterModule.forRoot(routes, { useHash: true })],  exports: [RouterModule],})export class AppRoutingModule {}","projects/example-app/src/app/app.module.ts":"import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { HttpClientModule } from '@angular/common/http';import { BrowserModule } from '@angular/platform-browser';import { BrowserAnimationsModule } from '@angular/platform-browser/animations';import { StoreModule } from '@ngrx/store';import { EffectsModule } from '@ngrx/effects';import { DBModule } from '@ngrx/db';import { StoreRouterConnectingModule } from '@ngrx/router-store';import { StoreDevtoolsModule } from '@ngrx/store-devtools';import { CoreModule } from './core/core.module';import { AuthModule } from './auth/auth.module';import { reducers, metaReducers } from './reducers';import { schema } from './db';import { AppComponent } from './core/containers/app.component';import { environment } from '../environments/environment';import { AppRoutingModule } from './app-routing.module';@NgModule({  imports: [    CommonModule,    BrowserModule,    BrowserAnimationsModule,    HttpClientModule,    AuthModule,    AppRoutingModule,    /**     * StoreModule.forRoot is imported once in the root module, accepting a reducer     * function or object map of reducer functions. If passed an object of     * reducers, combineReducers will be run creating your application     * meta-reducer. This returns all providers for an @ngrx/store     * based application.     */    StoreModule.forRoot(reducers, { metaReducers }),    /**     * @ngrx/router-store keeps router state up-to-date in the store.     */    StoreRouterConnectingModule.forRoot(),    /**     * Store devtools instrument the store retaining past versions of state     * and recalculating new states. This enables powerful time-travel     * debugging.     *     * To use the debugger, install the Redux Devtools extension for either     * Chrome or Firefox     *     * See: https://github.com/zalmoxisus/redux-devtools-extension     */    StoreDevtoolsModule.instrument({      name: 'NgRx Book Store App',      logOnly: environment.production,    }),    /**     * EffectsModule.forRoot() is imported once in the root module and     * sets up the effects class to be initialized immediately when the     * application starts.     *     * See: https://github.com/ngrx/platform/blob/master/docs/effects/api.md#forroot     */    EffectsModule.forRoot([]),    /**     * `provideDB` sets up @ngrx/db with the provided schema and makes the Database     * service available.     */    DBModule.provideDB(schema),    CoreModule,  ],  bootstrap: [AppComponent],})export class AppModule {}","projects/example-app/src/app/auth/actions/auth.actions.ts":"import { Action } from '@ngrx/store';import { User, Authenticate } from '../models/user';export enum AuthActionTypes {  Login = '[Auth] Login',  Logout = '[Auth] Logout',  LoginSuccess = '[Auth] Login Success',  LoginFailure = '[Auth] Login Failure',  LoginRedirect = '[Auth] Login Redirect',}export class Login implements Action {  readonly type = AuthActionTypes.Login;  constructor(public payload: Authenticate) {}}export class LoginSuccess implements Action {  readonly type = AuthActionTypes.LoginSuccess;  constructor(public payload: { user: User }) {}}export class LoginFailure implements Action {  readonly type = AuthActionTypes.LoginFailure;  constructor(public payload: any) {}}export class LoginRedirect implements Action {  readonly type = AuthActionTypes.LoginRedirect;}export class Logout implements Action {  readonly type = AuthActionTypes.Logout;}export type AuthActionsUnion =  | Login  | LoginSuccess  | LoginFailure  | LoginRedirect  | Logout;","projects/example-app/src/app/auth/auth-routing.module.ts":"import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';import { LoginPageComponent } from './containers/login-page.component';const routes: Routes = [{ path: 'login', component: LoginPageComponent }];@NgModule({  imports: [RouterModule.forChild(routes)],  exports: [RouterModule],})export class AuthRoutingModule {}","projects/example-app/src/app/auth/auth.module.ts":"import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { ReactiveFormsModule } from '@angular/forms';import { StoreModule } from '@ngrx/store';import { EffectsModule } from '@ngrx/effects';import { LoginPageComponent } from './containers/login-page.component';import { LoginFormComponent } from './components/login-form.component';import { AuthEffects } from './effects/auth.effects';import { reducers } from './reducers';import { MaterialModule } from '../material';import { AuthRoutingModule } from './auth-routing.module';export const COMPONENTS = [LoginPageComponent, LoginFormComponent];@NgModule({  imports: [    CommonModule,    ReactiveFormsModule,    MaterialModule,    AuthRoutingModule,    StoreModule.forFeature('auth', reducers),    EffectsModule.forFeature([AuthEffects]),  ],  declarations: COMPONENTS,})export class AuthModule {}","projects/example-app/src/app/auth/components/login-form.component.ts":"import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';import { FormGroup, FormControl } from '@angular/forms';import { Authenticate } from '../models/user';@Component({  selector: 'bc-login-form',  template: `    <mat-card>      <mat-card-title>Login</mat-card-title>      <mat-card-content>        <form [formGroup]=\"form\" (ngSubmit)=\"submit()\">          <p>            <mat-form-field>              <input type=\"text\" matInput placeholder=\"Username\" formControlName=\"username\">            </mat-form-field>          </p>          <p>            <mat-form-field>              <input type=\"password\" matInput placeholder=\"Password\" formControlName=\"password\">            </mat-form-field>          </p>          <p *ngIf=\"errorMessage\" class=\"loginError\">            {{ errorMessage }}          </p>          <p class=\"loginButtons\">            <button type=\"submit\" mat-button>Login</button>          </p>        </form>      </mat-card-content>    </mat-card>  `,  styles: [    `      :host {        display: flex;        justify-content: center;        margin: 72px 0;      }      .mat-form-field {        width: 100%;        min-width: 300px;      }      mat-card-title,      mat-card-content {        display: flex;        justify-content: center;      }      .loginError {        padding: 16px;        width: 300px;        color: white;        background-color: red;      }      .loginButtons {        display: flex;        flex-direction: row;        justify-content: flex-end;      }    `,  ],})export class LoginFormComponent implements OnInit {  @Input()  set pending(isPending: boolean) {    if (isPending) {      this.form.disable();    } else {      this.form.enable();    }  }  @Input() errorMessage: string | null;  @Output() submitted = new EventEmitter<Authenticate>();  form: FormGroup = new FormGroup({    username: new FormControl(''),    password: new FormControl(''),  });  constructor() {}  ngOnInit() {}  submit() {    if (this.form.valid) {      this.submitted.emit(this.form.value);    }  }}","projects/example-app/src/app/auth/containers/login-page.component.ts":"import { Component, OnInit } from '@angular/core';import { Store, select } from '@ngrx/store';import { Authenticate } from '../models/user';import * as fromAuth from '../reducers';import * as AuthActions from '../actions/auth.actions';@Component({  selector: 'bc-login-page',  template: `    <bc-login-form      (submitted)=\"onSubmit($event)\"      [pending]=\"pending$ | async\"      [errorMessage]=\"error$ | async\">    </bc-login-form>  `,  styles: [],})export class LoginPageComponent implements OnInit {  pending$ = this.store.pipe(select(fromAuth.getLoginPagePending));  error$ = this.store.pipe(select(fromAuth.getLoginPageError));  constructor(private store: Store<fromAuth.State>) {}  ngOnInit() {}  onSubmit($event: Authenticate) {    this.store.dispatch(new AuthActions.Login($event));  }}","projects/example-app/src/app/auth/effects/auth.effects.ts":"import { Injectable } from '@angular/core';import { Router } from '@angular/router';import { Actions, Effect, ofType } from '@ngrx/effects';import { of } from 'rxjs';import { catchError, exhaustMap, map, tap } from 'rxjs/operators';import {  AuthActionTypes,  Login,  LoginFailure,  LoginSuccess,} from '../actions/auth.actions';import { Authenticate } from '../models/user';import { AuthService } from '../services/auth.service';@Injectable()export class AuthEffects {  @Effect()  login$ = this.actions$.pipe(    ofType<Login>(AuthActionTypes.Login),    map(action => action.payload),    exhaustMap((auth: Authenticate) =>      this.authService.login(auth).pipe(        map(user => new LoginSuccess({ user })),        catchError(error => of(new LoginFailure(error)))      )    )  );  @Effect({ dispatch: false })  loginSuccess$ = this.actions$.pipe(    ofType(AuthActionTypes.LoginSuccess),    tap(() => this.router.navigate(['/']))  );  @Effect({ dispatch: false })  loginRedirect$ = this.actions$.pipe(    ofType(AuthActionTypes.LoginRedirect, AuthActionTypes.Logout),    tap(authed => {      this.router.navigate(['/login']);    })  );  constructor(    private actions$: Actions,    private authService: AuthService,    private router: Router  ) {}}","projects/example-app/src/app/auth/models/user.ts":"export interface Authenticate {  username: string;  password: string;}export interface User {  name: string;}","projects/example-app/src/app/auth/reducers/auth.reducer.ts":"import { AuthActionsUnion, AuthActionTypes } from './../actions/auth.actions';import { User } from '../models/user';export interface State {  user: User | null;}export const initialState: State = {  user: null,};export function reducer(state = initialState, action: AuthActionsUnion): State {  switch (action.type) {    case AuthActionTypes.LoginSuccess: {      return {        ...state,        user: action.payload.user,      };    }    case AuthActionTypes.Logout: {      return initialState;    }    default: {      return state;    }  }}export const getUser = (state: State) => state.user;","projects/example-app/src/app/auth/reducers/index.ts":"import {  createSelector,  createFeatureSelector,  ActionReducerMap,} from '@ngrx/store';import * as fromRoot from '../../reducers';import * as fromAuth from './auth.reducer';import * as fromLoginPage from './login-page.reducer';import { AuthActionsUnion } from '../actions/auth.actions';export interface AuthState {  status: fromAuth.State;  loginPage: fromLoginPage.State;}export interface State extends fromRoot.State {  auth: AuthState;}export const reducers: ActionReducerMap<AuthState, AuthActionsUnion> = {  status: fromAuth.reducer,  loginPage: fromLoginPage.reducer,};export const selectAuthState = createFeatureSelector<State, AuthState>('auth');export const selectAuthStatusState = createSelector(  selectAuthState,  (state: AuthState) => state.status);export const getUser = createSelector(selectAuthStatusState, fromAuth.getUser);export const getLoggedIn = createSelector(getUser, user => !!user);export const selectLoginPageState = createSelector(  selectAuthState,  (state: AuthState) => state.loginPage);export const getLoginPageError = createSelector(  selectLoginPageState,  fromLoginPage.getError);export const getLoginPagePending = createSelector(  selectLoginPageState,  fromLoginPage.getPending);","projects/example-app/src/app/auth/reducers/login-page.reducer.ts":"import { AuthActionTypes, AuthActionsUnion } from './../actions/auth.actions';export interface State {  error: string | null;  pending: boolean;}export const initialState: State = {  error: null,  pending: false,};export function reducer(state = initialState, action: AuthActionsUnion): State {  switch (action.type) {    case AuthActionTypes.Login: {      return {        ...state,        error: null,        pending: true,      };    }    case AuthActionTypes.LoginSuccess: {      return {        ...state,        error: null,        pending: false,      };    }    case AuthActionTypes.LoginFailure: {      return {        ...state,        error: action.payload,        pending: false,      };    }    default: {      return state;    }  }}export const getError = (state: State) => state.error;export const getPending = (state: State) => state.pending;","projects/example-app/src/app/auth/services/auth-guard.service.ts":"import { Injectable } from '@angular/core';import { CanActivate } from '@angular/router';import { Store, select } from '@ngrx/store';import { Observable } from 'rxjs';import { map, take } from 'rxjs/operators';import * as AuthActions from '../actions/auth.actions';import * as fromAuth from '../reducers';@Injectable({  providedIn: 'root',})export class AuthGuard implements CanActivate {  constructor(private store: Store<fromAuth.State>) {}  canActivate(): Observable<boolean> {    return this.store.pipe(      select(fromAuth.getLoggedIn),      map(authed => {        if (!authed) {          this.store.dispatch(new AuthActions.LoginRedirect());          return false;        }        return true;      }),      take(1)    );  }}","projects/example-app/src/app/auth/services/auth.service.ts":"import { Injectable } from '@angular/core';import { Observable, of, throwError } from 'rxjs';import { Authenticate, User } from '../models/user';@Injectable({  providedIn: 'root',})export class AuthService {  constructor() {}  login({ username, password }: Authenticate): Observable<User> {    /**     * Simulate a failed login to display the error     * message for the login form.     */    if (username !== 'test') {      return throwError('Invalid username or password');    }    return of({ name: 'User' });  }  logout() {    return of(true);  }}","projects/example-app/src/app/books/actions/book.actions.ts":"import { Action } from '@ngrx/store';import { Book } from '../models/book';export enum BookActionTypes {  Search = '[Book] Search',  SearchComplete = '[Book] Search Complete',  SearchError = '[Book] Search Error',  Load = '[Book] Load',  Select = '[Book] Select',}/** * Every action is comprised of at least a type and an optional * payload. Expressing actions as classes enables powerful * type checking in reducer functions. * * See Discriminated Unions: https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions */export class Search implements Action {  readonly type = BookActionTypes.Search;  constructor(public payload: string) {}}export class SearchComplete implements Action {  readonly type = BookActionTypes.SearchComplete;  constructor(public payload: Book[]) {}}export class SearchError implements Action {  readonly type = BookActionTypes.SearchError;  constructor(public payload: string) {}}export class Load implements Action {  readonly type = BookActionTypes.Load;  constructor(public payload: Book) {}}export class Select implements Action {  readonly type = BookActionTypes.Select;  constructor(public payload: string) {}}/** * Export a type alias of all actions in this action group * so that reducers can easily compose action types */export type BookActionsUnion =  | Search  | SearchComplete  | SearchError  | Load  | Select;","projects/example-app/src/app/books/actions/collection.actions.ts":"import { Action } from '@ngrx/store';import { Book } from '../models/book';export enum CollectionActionTypes {  AddBook = '[Collection] Add Book',  AddBookSuccess = '[Collection] Add Book Success',  AddBookFail = '[Collection] Add Book Fail',  RemoveBook = '[Collection] Remove Book',  RemoveBookSuccess = '[Collection] Remove Book Success',  RemoveBookFail = '[Collection] Remove Book Fail',  Load = '[Collection] Load',  LoadSuccess = '[Collection] Load Success',  LoadFail = '[Collection] Load Fail',}/** * Add Book to Collection Actions */export class AddBook implements Action {  readonly type = CollectionActionTypes.AddBook;  constructor(public payload: Book) {}}export class AddBookSuccess implements Action {  readonly type = CollectionActionTypes.AddBookSuccess;  constructor(public payload: Book) {}}export class AddBookFail implements Action {  readonly type = CollectionActionTypes.AddBookFail;  constructor(public payload: Book) {}}/** * Remove Book from Collection Actions */export class RemoveBook implements Action {  readonly type = CollectionActionTypes.RemoveBook;  constructor(public payload: Book) {}}export class RemoveBookSuccess implements Action {  readonly type = CollectionActionTypes.RemoveBookSuccess;  constructor(public payload: Book) {}}export class RemoveBookFail implements Action {  readonly type = CollectionActionTypes.RemoveBookFail;  constructor(public payload: Book) {}}/** * Load Collection Actions */export class Load implements Action {  readonly type = CollectionActionTypes.Load;}export class LoadSuccess implements Action {  readonly type = CollectionActionTypes.LoadSuccess;  constructor(public payload: Book[]) {}}export class LoadFail implements Action {  readonly type = CollectionActionTypes.LoadFail;  constructor(public payload: any) {}}export type CollectionActionsUnion =  | AddBook  | AddBookSuccess  | AddBookFail  | RemoveBook  | RemoveBookSuccess  | RemoveBookFail  | Load  | LoadSuccess  | LoadFail;","projects/example-app/src/app/books/books-routing.module.ts":"import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';import { FindBookPageComponent } from './containers/find-book-page.component';import { ViewBookPageComponent } from './containers/view-book-page.component';import { CollectionPageComponent } from './containers/collection-page.component';import { BookExistsGuard } from './guards/book-exists.guard';export const routes: Routes = [  { path: 'find', component: FindBookPageComponent },  {    path: ':id',    component: ViewBookPageComponent,    canActivate: [BookExistsGuard],  },  { path: '', component: CollectionPageComponent },];@NgModule({  imports: [RouterModule.forChild(routes)],  exports: [RouterModule],})export class BooksRoutingModule {}","projects/example-app/src/app/books/books.module.ts":"import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { StoreModule } from '@ngrx/store';import { EffectsModule } from '@ngrx/effects';import { ComponentsModule } from './components';import { BookEffects } from './effects/book.effects';import { CollectionEffects } from './effects/collection.effects';import { FindBookPageComponent } from './containers/find-book-page.component';import { ViewBookPageComponent } from './containers/view-book-page.component';import { SelectedBookPageComponent } from './containers/selected-book-page.component';import { CollectionPageComponent } from './containers/collection-page.component';import { MaterialModule } from '../material';import { reducers } from './reducers';import { BooksRoutingModule } from './books-routing.module';@NgModule({  imports: [    CommonModule,    MaterialModule,    ComponentsModule,    BooksRoutingModule,    /**     * StoreModule.forFeature is used for composing state     * from feature modules. These modules can be loaded     * eagerly or lazily and will be dynamically added to     * the existing state.     */    StoreModule.forFeature('books', reducers),    /**     * Effects.forFeature is used to register effects     * from feature modules. Effects can be loaded     * eagerly or lazily and will be started immediately.     *     * All Effects will only be instantiated once regardless of     * whether they are registered once or multiple times.     */    EffectsModule.forFeature([BookEffects, CollectionEffects]),  ],  declarations: [    FindBookPageComponent,    ViewBookPageComponent,    SelectedBookPageComponent,    CollectionPageComponent,  ],})export class BooksModule {}","projects/example-app/src/app/books/components/book-authors.component.ts":"import { Component, Input } from '@angular/core';import { Book } from '../models/book';@Component({  selector: 'bc-book-authors',  template: `    <h5 mat-subheader>Written By:</h5>    <span>      {{ authors | bcAddCommas }}    </span>  `,  styles: [    `      h5 {        margin-bottom: 5px;      }    `,  ],})export class BookAuthorsComponent {  @Input() book: Book;  get authors() {    return this.book.volumeInfo.authors;  }}","projects/example-app/src/app/books/components/book-detail.component.ts":"import { Component, Input, Output, EventEmitter } from '@angular/core';import { Book } from '../models/book';@Component({  selector: 'bc-book-detail',  template: `    <mat-card *ngIf=\"book\">      <mat-card-title-group>        <mat-card-title>{{ title }}</mat-card-title>        <mat-card-subtitle *ngIf=\"subtitle\">{{ subtitle }}</mat-card-subtitle>        <img mat-card-sm-image *ngIf=\"thumbnail\" [src]=\"thumbnail\"/>      </mat-card-title-group>      <mat-card-content>        <p [innerHtml]=\"description\"></p>      </mat-card-content>      <mat-card-footer class=\"footer\">        <bc-book-authors [book]=\"book\"></bc-book-authors>      </mat-card-footer>      <mat-card-actions align=\"start\">        <button mat-raised-button color=\"warn\" *ngIf=\"inCollection\" (click)=\"remove.emit(book)\">        Remove Book from Collection        </button>        <button mat-raised-button color=\"primary\" *ngIf=\"!inCollection\" (click)=\"add.emit(book)\">        Add Book to Collection        </button>      </mat-card-actions>    </mat-card>  `,  styles: [    `      :host {        display: flex;        justify-content: center;        margin: 75px 0;      }      mat-card {        max-width: 600px;      }      mat-card-title-group {        margin-left: 0;      }      img {        width: 60px;        min-width: 60px;        margin-left: 5px;      }      mat-card-content {        margin: 15px 0 50px;      }      mat-card-actions {        margin: 25px 0 0 !important;      }      mat-card-footer {        padding: 0 25px 25px;        position: relative;      }    `,  ],})export class BookDetailComponent {  /**   * Presentational components receive data through @Input() and communicate events   * through @Output() but generally maintain no internal state of their   * own. All decisions are delegated to 'container', or 'smart'   * components before data updates flow back down.   *   * More on 'smart' and 'presentational' components: https://gist.github.com/btroncone/a6e4347326749f938510#utilizing-container-components   */  @Input() book: Book;  @Input() inCollection: boolean;  @Output() add = new EventEmitter<Book>();  @Output() remove = new EventEmitter<Book>();  /**   * Tip: Utilize getters to keep templates clean   */  get id() {    return this.book.id;  }  get title() {    return this.book.volumeInfo.title;  }  get subtitle() {    return this.book.volumeInfo.subtitle;  }  get description() {    return this.book.volumeInfo.description;  }  get thumbnail() {    return (      this.book.volumeInfo.imageLinks &&      this.book.volumeInfo.imageLinks.smallThumbnail &&      this.book.volumeInfo.imageLinks.smallThumbnail.replace('http:', '')    );  }}","projects/example-app/src/app/books/components/book-preview-list.component.ts":"import { Component, Input } from '@angular/core';import { Book } from '../models/book';@Component({  selector: 'bc-book-preview-list',  template: `    <bc-book-preview *ngFor=\"let book of books\" [book]=\"book\"></bc-book-preview>  `,  styles: [    `      :host {        display: flex;        flex-wrap: wrap;        justify-content: center;      }    `,  ],})export class BookPreviewListComponent {  @Input() books: Book[];}","projects/example-app/src/app/books/components/book-preview.component.ts":"import { Component, Input } from '@angular/core';import { Book } from '../models/book';@Component({  selector: 'bc-book-preview',  template: `    <a [routerLink]=\"['/books', id]\">      <mat-card>        <mat-card-title-group>          <img mat-card-sm-image *ngIf=\"thumbnail\" [src]=\"thumbnail\"/>          <mat-card-title>{{ title | bcEllipsis:35 }}</mat-card-title>          <mat-card-subtitle *ngIf=\"subtitle\">{{ subtitle | bcEllipsis:40 }}</mat-card-subtitle>        </mat-card-title-group>        <mat-card-content>          <p *ngIf=\"description\">{{ description | bcEllipsis }}</p>        </mat-card-content>        <mat-card-footer>          <bc-book-authors [book]=\"book\"></bc-book-authors>        </mat-card-footer>      </mat-card>    </a>  `,  styles: [    `      :host {        display: flex;      }      :host a {        display: flex;      }      mat-card {        width: 400px;        margin: 15px;        display: flex;        flex-flow: column;        justify-content: space-between;      }      @media only screen and (max-width: 768px) {        mat-card {          margin: 15px 0 !important;        }      }      mat-card:hover {        box-shadow: 3px 3px 16px -2px rgba(0, 0, 0, 0.5);      }      mat-card-title {        margin-right: 10px;      }      mat-card-title-group {        margin: 0;      }      a {        color: inherit;        text-decoration: none;      }      img {        width: 60px;        min-width: 60px;        margin-left: 5px;      }      mat-card-content {        margin-top: 15px;        margin: 15px 0 0;      }      span {        display: inline-block;        font-size: 13px;      }      mat-card-footer {        padding: 0 25px 25px;      }    `,  ],})export class BookPreviewComponent {  @Input() book: Book;  get id() {    return this.book.id;  }  get title() {    return this.book.volumeInfo.title;  }  get subtitle() {    return this.book.volumeInfo.subtitle;  }  get description() {    return this.book.volumeInfo.description;  }  get thumbnail(): string | boolean {    if (this.book.volumeInfo.imageLinks) {      return this.book.volumeInfo.imageLinks.smallThumbnail.replace(        'http:',        ''      );    }    return false;  }}","projects/example-app/src/app/books/components/book-search.component.ts":"import { Component, Output, Input, EventEmitter } from '@angular/core';@Component({  selector: 'bc-book-search',  template: `    <mat-card>      <mat-card-title>Find a Book</mat-card-title>      <mat-card-content>        <mat-form-field>          <input matInput placeholder=\"Search for a book\" [value]=\"query\" (keyup)=\"search.emit($event.target.value)\">        </mat-form-field>        <mat-spinner [class.show]=\"searching\" [diameter]=\"30\" [strokeWidth]=\"3\"></mat-spinner>      </mat-card-content>      <mat-card-footer><span *ngIf=\"error\">{{error}}</span></mat-card-footer>    </mat-card>  `,  styles: [    `      mat-card-title,      mat-card-content,      mat-card-footer {        display: flex;        justify-content: center;      }      mat-card-footer {        color: #ff0000;        padding: 5px 0;      }      .mat-form-field {        min-width: 300px;        margin-right: 10px; // Make room for the spinner      }      .mat-spinner {        position: relative;        top: 10px;        left: 10px;        visibility: hidden;      }      .mat-spinner.show {        visibility: visible;      }    `,  ],})export class BookSearchComponent {  @Input() query = '';  @Input() searching = false;  @Input() error = '';  @Output() search = new EventEmitter<string>();}","projects/example-app/src/app/books/components/index.ts":"import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { ReactiveFormsModule } from '@angular/forms';import { RouterModule } from '@angular/router';import { BookAuthorsComponent } from './book-authors.component';import { BookDetailComponent } from './book-detail.component';import { BookPreviewComponent } from './book-preview.component';import { BookPreviewListComponent } from './book-preview-list.component';import { BookSearchComponent } from './book-search.component';import { PipesModule } from '../../shared/pipes';import { MaterialModule } from '../../material';export const COMPONENTS = [  BookAuthorsComponent,  BookDetailComponent,  BookPreviewComponent,  BookPreviewListComponent,  BookSearchComponent,];@NgModule({  imports: [    CommonModule,    ReactiveFormsModule,    MaterialModule,    RouterModule,    PipesModule,  ],  declarations: COMPONENTS,  exports: COMPONENTS,})export class ComponentsModule {}","projects/example-app/src/app/books/containers/collection-page.component.ts":"import { ChangeDetectionStrategy, Component, OnInit } from '@angular/core';import { select, Store } from '@ngrx/store';import { Observable } from 'rxjs';import * as CollectionActions from '../actions/collection.actions';import { Book } from '../models/book';import * as fromBooks from '../reducers';@Component({  selector: 'bc-collection-page',  changeDetection: ChangeDetectionStrategy.OnPush,  template: `    <mat-card>      <mat-card-title>My Collection</mat-card-title>    </mat-card>    <bc-book-preview-list [books]=\"books$ | async\"></bc-book-preview-list>  `,  /**   * Container components are permitted to have just enough styles   * to bring the view together. If the number of styles grow,   * consider breaking them out into presentational   * components.   */  styles: [    `      mat-card-title {        display: flex;        justify-content: center;      }    `,  ],})export class CollectionPageComponent implements OnInit {  books$: Observable<Book[]>;  constructor(private store: Store<fromBooks.State>) {    this.books$ = store.pipe(select(fromBooks.getBookCollection));  }  ngOnInit() {    this.store.dispatch(new CollectionActions.Load());  }}","projects/example-app/src/app/books/containers/find-book-page.component.ts":"import { ChangeDetectionStrategy, Component } from '@angular/core';import { select, Store } from '@ngrx/store';import { Observable } from 'rxjs';import { take } from 'rxjs/operators';import * as BookActions from '../actions/book.actions';import { Book } from '../models/book';import * as fromBooks from '../reducers';@Component({  selector: 'bc-find-book-page',  changeDetection: ChangeDetectionStrategy.OnPush,  template: `    <bc-book-search      [query]=\"searchQuery$ | async\"      [searching]=\"loading$ | async\"      [error]=\"error$ | async\"      (search)=\"search($event)\">    </bc-book-search>    <bc-book-preview-list      [books]=\"books$ | async\">    </bc-book-preview-list>  `,})export class FindBookPageComponent {  searchQuery$: Observable<string>;  books$: Observable<Book[]>;  loading$: Observable<boolean>;  error$: Observable<string>;  constructor(private store: Store<fromBooks.State>) {    this.searchQuery$ = store.pipe(      select(fromBooks.getSearchQuery),      take(1)    );    this.books$ = store.pipe(select(fromBooks.getSearchResults));    this.loading$ = store.pipe(select(fromBooks.getSearchLoading));    this.error$ = store.pipe(select(fromBooks.getSearchError));  }  search(query: string) {    this.store.dispatch(new BookActions.Search(query));  }}","projects/example-app/src/app/books/containers/selected-book-page.component.ts":"import { Component, ChangeDetectionStrategy } from '@angular/core';import { Store, select } from '@ngrx/store';import { Observable } from 'rxjs';import * as fromBooks from '../reducers';import * as CollectionActions from '../actions/collection.actions';import { Book } from '../models/book';@Component({  selector: 'bc-selected-book-page',  changeDetection: ChangeDetectionStrategy.OnPush,  template: `    <bc-book-detail      [book]=\"book$ | async\"      [inCollection]=\"isSelectedBookInCollection$ | async\"      (add)=\"addToCollection($event)\"      (remove)=\"removeFromCollection($event)\">    </bc-book-detail>  `,})export class SelectedBookPageComponent {  book$: Observable<Book>;  isSelectedBookInCollection$: Observable<boolean>;  constructor(private store: Store<fromBooks.State>) {    this.book$ = store.pipe(select(fromBooks.getSelectedBook)) as Observable<      Book    >;    this.isSelectedBookInCollection$ = store.pipe(      select(fromBooks.isSelectedBookInCollection)    );  }  addToCollection(book: Book) {    this.store.dispatch(new CollectionActions.AddBook(book));  }  removeFromCollection(book: Book) {    this.store.dispatch(new CollectionActions.RemoveBook(book));  }}","projects/example-app/src/app/books/containers/view-book-page.component.ts":"import { Component, OnDestroy, ChangeDetectionStrategy } from '@angular/core';import { ActivatedRoute } from '@angular/router';import { Store } from '@ngrx/store';import { Subscription } from 'rxjs';import { map } from 'rxjs/operators';import * as fromBooks from '../reducers';import * as BookActions from '../actions/book.actions';/** * Note: Container components are also reusable. Whether or not * a component is a presentation component or a container * component is an implementation detail. * * The View Book Page's responsibility is to map router params * to a 'Select' book action. Actually showing the selected * book remains a responsibility of the * SelectedBookPageComponent */@Component({  selector: 'bc-view-book-page',  changeDetection: ChangeDetectionStrategy.OnPush,  template: `    <bc-selected-book-page></bc-selected-book-page>  `,})export class ViewBookPageComponent implements OnDestroy {  actionsSubscription: Subscription;  constructor(store: Store<fromBooks.State>, route: ActivatedRoute) {    this.actionsSubscription = route.params      .pipe(map(params => new BookActions.Select(params.id)))      .subscribe(store);  }  ngOnDestroy() {    this.actionsSubscription.unsubscribe();  }}","projects/example-app/src/app/books/effects/book.effects.ts":"import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';import { Actions, Effect, ofType } from '@ngrx/effects';import { Action } from '@ngrx/store';import { asyncScheduler, EMPTY as empty, Observable, of } from 'rxjs';import {  catchError,  debounceTime,  map,  skip,  switchMap,  takeUntil,} from 'rxjs/operators';import { GoogleBooksService } from '../../core/services/google-books.service';import {  BookActionTypes,  Search,  SearchComplete,  SearchError,} from '../actions/book.actions';import { Book } from '../models/book';/** * Effects offer a way to isolate and easily test side-effects within your * application. * * If you are unfamiliar with the operators being used in these examples, please * check out the sources below: * * Official Docs: http://reactivex.io/rxjs/manual/overview.html#categories-of-operators * RxJS 5 Operators By Example: https://gist.github.com/btroncone/d6cf141d6f2c00dc6b35 */@Injectable()export class BookEffects {  @Effect()  search$ = ({ debounce = 300, scheduler = asyncScheduler } = {}): Observable<    Action  > =>    this.actions$.pipe(      ofType<Search>(BookActionTypes.Search),      debounceTime(debounce, scheduler),      map(action => action.payload),      switchMap(query => {        if (query === '') {          return empty;        }        const nextSearch$ = this.actions$.pipe(          ofType(BookActionTypes.Search),          skip(1)        );        return this.googleBooks.searchBooks(query).pipe(          takeUntil(nextSearch$),          map((books: Book[]) => new SearchComplete(books)),          catchError(err => of(new SearchError(err)))        );      })    );  constructor(    private actions$: Actions,    private googleBooks: GoogleBooksService  ) {}}","projects/example-app/src/app/books/effects/collection.effects.ts":"import { Injectable } from '@angular/core';import { Database } from '@ngrx/db';import { Actions, Effect, ofType } from '@ngrx/effects';import { Action } from '@ngrx/store';import { defer, Observable, of } from 'rxjs';import { catchError, map, mergeMap, switchMap, toArray } from 'rxjs/operators';import { Book } from '../models/book';import {  AddBook,  AddBookFail,  AddBookSuccess,  CollectionActionTypes,  LoadFail,  LoadSuccess,  RemoveBook,  RemoveBookFail,  RemoveBookSuccess,} from './../actions/collection.actions';@Injectable()export class CollectionEffects {  /**   * This effect does not yield any actions back to the store. Set   * `dispatch` to false to hint to @ngrx/effects that it should   * ignore any elements of this effect stream.   *   * The `defer` observable accepts an observable factory function   * that is called when the observable is subscribed to.   * Wrapping the database open call in `defer` makes   * effect easier to test.   */  @Effect({ dispatch: false })  openDB$: Observable<any> = defer(() => {    return this.db.open('books_app');  });  @Effect()  loadCollection$: Observable<Action> = this.actions$.pipe(    ofType(CollectionActionTypes.Load),    switchMap(() =>      this.db.query('books').pipe(        toArray(),        map((books: Book[]) => new LoadSuccess(books)),        catchError(error => of(new LoadFail(error)))      )    )  );  @Effect()  addBookToCollection$: Observable<Action> = this.actions$.pipe(    ofType<AddBook>(CollectionActionTypes.AddBook),    map(action => action.payload),    mergeMap(book =>      this.db.insert('books', [book]).pipe(        map(() => new AddBookSuccess(book)),        catchError(() => of(new AddBookFail(book)))      )    )  );  @Effect()  removeBookFromCollection$: Observable<Action> = this.actions$.pipe(    ofType<RemoveBook>(CollectionActionTypes.RemoveBook),    map(action => action.payload),    mergeMap(book =>      this.db.executeWrite('books', 'delete', [book.id]).pipe(        map(() => new RemoveBookSuccess(book)),        catchError(() => of(new RemoveBookFail(book)))      )    )  );  constructor(private actions$: Actions, private db: Database) {}}","projects/example-app/src/app/books/guards/book-exists.guard.ts":"import { Injectable } from '@angular/core';import { ActivatedRouteSnapshot, CanActivate, Router } from '@angular/router';import { select, Store } from '@ngrx/store';import { Observable, of } from 'rxjs';import { catchError, filter, map, switchMap, take, tap } from 'rxjs/operators';import { GoogleBooksService } from '../../core/services/google-books.service';import * as BookActions from '../actions/book.actions';import * as fromBooks from '../reducers';/** * Guards are hooks into the route resolution process, providing an opportunity * to inform the router's navigation process whether the route should continue * to activate this route. Guards must return an observable of true or false. */@Injectable({  providedIn: 'root',})export class BookExistsGuard implements CanActivate {  constructor(    private store: Store<fromBooks.State>,    private googleBooks: GoogleBooksService,    private router: Router  ) {}  /**   * This method creates an observable that waits for the `loaded` property   * of the collection state to turn `true`, emitting one time once loading   * has finished.   */  waitForCollectionToLoad(): Observable<boolean> {    return this.store.pipe(      select(fromBooks.getCollectionLoaded),      filter(loaded => loaded),      take(1)    );  }  /**   * This method checks if a book with the given ID is already registered   * in the Store   */  hasBookInStore(id: string): Observable<boolean> {    return this.store.pipe(      select(fromBooks.getBookEntities),      map(entities => !!entities[id]),      take(1)    );  }  /**   * This method loads a book with the given ID from the API and caches   * it in the store, returning `true` or `false` if it was found.   */  hasBookInApi(id: string): Observable<boolean> {    return this.googleBooks.retrieveBook(id).pipe(      map(bookEntity => new BookActions.Load(bookEntity)),      tap((action: BookActions.Load) => this.store.dispatch(action)),      map(book => !!book),      catchError(() => {        this.router.navigate(['/404']);        return of(false);      })    );  }  /**   * `hasBook` composes `hasBookInStore` and `hasBookInApi`. It first checks   * if the book is in store, and if not it then checks if it is in the   * API.   */  hasBook(id: string): Observable<boolean> {    return this.hasBookInStore(id).pipe(      switchMap(inStore => {        if (inStore) {          return of(inStore);        }        return this.hasBookInApi(id);      })    );  }  /**   * This is the actual method the router will call when our guard is run.   *   * Our guard waits for the collection to load, then it checks if we need   * to request a book from the API or if we already have it in our cache.   * If it finds it in the cache or in the API, it returns an Observable   * of `true` and the route is rendered successfully.   *   * If it was unable to find it in our cache or in the API, this guard   * will return an Observable of `false`, causing the router to move   * on to the next candidate route. In this case, it will move on   * to the 404 page.   */  canActivate(route: ActivatedRouteSnapshot): Observable<boolean> {    return this.waitForCollectionToLoad().pipe(      switchMap(() => this.hasBook(route.params['id']))    );  }}","projects/example-app/src/app/books/models/book.ts":"export interface Book {  id: string;  volumeInfo: {    title: string;    subtitle: string;    authors: string[];    publisher: string;    publishDate: string;    description: string;    averageRating: number;    ratingsCount: number;    imageLinks: {      thumbnail: string;      smallThumbnail: string;    };  };}export function generateMockBook(): Book {  return {    id: '1',    volumeInfo: {      title: 'title',      subtitle: 'subtitle',      authors: ['author'],      publisher: 'publisher',      publishDate: '',      description: 'description',      averageRating: 3,      ratingsCount: 5,      imageLinks: {        thumbnail: 'string',        smallThumbnail: 'string',      },    },  };}","projects/example-app/src/app/books/reducers/books.reducer.ts":"import { createEntityAdapter, EntityAdapter, EntityState } from '@ngrx/entity';import { Book } from '../models/book';import { BookActionsUnion, BookActionTypes } from '../actions/book.actions';import {  CollectionActionsUnion,  CollectionActionTypes,} from '../actions/collection.actions';/** * @ngrx/entity provides a predefined interface for handling * a structured dictionary of records. This interface * includes an array of ids, and a dictionary of the provided * model type by id. This interface is extended to include * any additional interface properties. */export interface State extends EntityState<Book> {  selectedBookId: string | null;}/** * createEntityAdapter creates an object of many helper * functions for single or multiple operations * against the dictionary of records. The configuration * object takes a record id selector function and * a sortComparer option which is set to a compare * function if the records are to be sorted. */export const adapter: EntityAdapter<Book> = createEntityAdapter<Book>({  selectId: (book: Book) => book.id,  sortComparer: false,});/** * getInitialState returns the default initial state * for the generated entity state. Initial state * additional properties can also be defined. */export const initialState: State = adapter.getInitialState({  selectedBookId: null,});export function reducer(  state = initialState,  action: BookActionsUnion | CollectionActionsUnion): State {  switch (action.type) {    case BookActionTypes.SearchComplete:    case CollectionActionTypes.LoadSuccess: {      /**       * The addMany function provided by the created adapter       * adds many records to the entity dictionary       * and returns a new state including those records. If       * the collection is to be sorted, the adapter will       * sort each record upon entry into the sorted array.       */      return adapter.addMany(action.payload, state);    }    case BookActionTypes.Load: {      /**       * The addOne function provided by the created adapter       * adds one record to the entity dictionary       * and returns a new state including that records if it doesn't       * exist already. If the collection is to be sorted, the adapter will       * insert the new record into the sorted array.       */      return adapter.addOne(action.payload, state);    }    case BookActionTypes.Select: {      return {        ...state,        selectedBookId: action.payload,      };    }    default: {      return state;    }  }}/** * Because the data structure is defined within the reducer it is optimal to * locate our selector functions at this level. If store is to be thought of * as a database, and reducers the tables, selectors can be considered the * queries into said database. Remember to keep your selectors small and * focused so they can be combined and composed to fit each particular * use-case. */export const getSelectedId = (state: State) => state.selectedBookId;","projects/example-app/src/app/books/reducers/collection.reducer.ts":"import {  CollectionActionTypes,  CollectionActionsUnion,} from './../actions/collection.actions';export interface State {  loaded: boolean;  loading: boolean;  ids: string[];}const initialState: State = {  loaded: false,  loading: false,  ids: [],};export function reducer(  state = initialState,  action: CollectionActionsUnion): State {  switch (action.type) {    case CollectionActionTypes.Load: {      return {        ...state,        loading: true,      };    }    case CollectionActionTypes.LoadSuccess: {      return {        loaded: true,        loading: false,        ids: action.payload.map(book => book.id),      };    }    case CollectionActionTypes.AddBookSuccess:    case CollectionActionTypes.RemoveBookFail: {      if (state.ids.indexOf(action.payload.id) > -1) {        return state;      }      return {        ...state,        ids: [...state.ids, action.payload.id],      };    }    case CollectionActionTypes.RemoveBookSuccess:    case CollectionActionTypes.AddBookFail: {      return {        ...state,        ids: state.ids.filter(id => id !== action.payload.id),      };    }    default: {      return state;    }  }}export const getLoaded = (state: State) => state.loaded;export const getLoading = (state: State) => state.loading;export const getIds = (state: State) => state.ids;","projects/example-app/src/app/books/reducers/index.ts":"import {  createSelector,  createFeatureSelector,  ActionReducerMap,} from '@ngrx/store';import * as fromSearch from './search.reducer';import * as fromBooks from './books.reducer';import * as fromCollection from './collection.reducer';import * as fromRoot from '../../reducers';export interface BooksState {  search: fromSearch.State;  books: fromBooks.State;  collection: fromCollection.State;}export interface State extends fromRoot.State {  books: BooksState;}export const reducers: ActionReducerMap<BooksState, any> = {  search: fromSearch.reducer,  books: fromBooks.reducer,  collection: fromCollection.reducer,};/** * A selector function is a map function factory. We pass it parameters and it * returns a function that maps from the larger state tree into a smaller * piece of state. This selector simply selects the `books` state. * * Selectors are used with the `select` operator. * * ```ts * class MyComponent { *   constructor(state$: Observable<State>) { *     this.booksState$ = state$.pipe(select(getBooksState)); *   } * } * ``` *//** * The createFeatureSelector function selects a piece of state from the root of the state object. * This is used for selecting feature states that are loaded eagerly or lazily. */export const getBooksState = createFeatureSelector<State, BooksState>('books');/** * Every reducer module exports selector functions, however child reducers * have no knowledge of the overall state tree. To make them usable, we * need to make new selectors that wrap them. * * The createSelector function creates very efficient selectors that are memoized and * only recompute when arguments change. The created selectors can also be composed * together to select different pieces of state. */export const getBookEntitiesState = createSelector(  getBooksState,  state => state.books);export const getSelectedBookId = createSelector(  getBookEntitiesState,  fromBooks.getSelectedId);/** * Adapters created with @ngrx/entity generate * commonly used selector functions including * getting all ids in the record set, a dictionary * of the records by id, an array of records and * the total number of records. This reduces boilerplate * in selecting records from the entity state. */export const {  selectIds: getBookIds,  selectEntities: getBookEntities,  selectAll: getAllBooks,  selectTotal: getTotalBooks,} = fromBooks.adapter.getSelectors(getBookEntitiesState);export const getSelectedBook = createSelector(  getBookEntities,  getSelectedBookId,  (entities, selectedId) => {    return selectedId && entities[selectedId];  });/** * Just like with the books selectors, we also have to compose the search * reducer's and collection reducer's selectors. */export const getSearchState = createSelector(  getBooksState,  (state: BooksState) => state.search);export const getSearchBookIds = createSelector(  getSearchState,  fromSearch.getIds);export const getSearchQuery = createSelector(  getSearchState,  fromSearch.getQuery);export const getSearchLoading = createSelector(  getSearchState,  fromSearch.getLoading);export const getSearchError = createSelector(  getSearchState,  fromSearch.getError);/** * Some selector functions create joins across parts of state. This selector * composes the search result IDs to return an array of books in the store. */export const getSearchResults = createSelector(  getBookEntities,  getSearchBookIds,  (books, searchIds) => {    return searchIds.map(id => books[id]);  });export const getCollectionState = createSelector(  getBooksState,  (state: BooksState) => state.collection);export const getCollectionLoaded = createSelector(  getCollectionState,  fromCollection.getLoaded);export const getCollectionLoading = createSelector(  getCollectionState,  fromCollection.getLoading);export const getCollectionBookIds = createSelector(  getCollectionState,  fromCollection.getIds);export const getBookCollection = createSelector(  getBookEntities,  getCollectionBookIds,  (entities, ids) => {    return ids.map(id => entities[id]);  });export const isSelectedBookInCollection = createSelector(  getCollectionBookIds,  getSelectedBookId,  (ids, selected) => {    return selected && ids.indexOf(selected) > -1;  });","projects/example-app/src/app/books/reducers/search.reducer.ts":"import { BookActionTypes, BookActionsUnion } from '../actions/book.actions';export interface State {  ids: string[];  loading: boolean;  error: string;  query: string;}const initialState: State = {  ids: [],  loading: false,  error: '',  query: '',};export function reducer(state = initialState, action: BookActionsUnion): State {  switch (action.type) {    case BookActionTypes.Search: {      const query = action.payload;      if (query === '') {        return {          ids: [],          loading: false,          error: '',          query,        };      }      return {        ...state,        loading: true,        error: '',        query,      };    }    case BookActionTypes.SearchComplete: {      return {        ids: action.payload.map(book => book.id),        loading: false,        error: '',        query: state.query,      };    }    case BookActionTypes.SearchError: {      return {        ...state,        loading: false,        error: action.payload,      };    }    default: {      return state;    }  }}export const getIds = (state: State) => state.ids;export const getQuery = (state: State) => state.query;export const getLoading = (state: State) => state.loading;export const getError = (state: State) => state.error;","projects/example-app/src/app/core/actions/layout.actions.ts":"import { Action } from '@ngrx/store';export enum LayoutActionTypes {  OpenSidenav = '[Layout] Open Sidenav',  CloseSidenav = '[Layout] Close Sidenav',}export class OpenSidenav implements Action {  readonly type = LayoutActionTypes.OpenSidenav;}export class CloseSidenav implements Action {  readonly type = LayoutActionTypes.CloseSidenav;}export type LayoutActionsUnion = OpenSidenav | CloseSidenav;","projects/example-app/src/app/core/components/layout.component.ts":"import { Component } from '@angular/core';@Component({  selector: 'bc-layout',  template: `    <mat-sidenav-container fullscreen>      <ng-content></ng-content>    </mat-sidenav-container>  `,  styles: [    `      mat-sidenav-container {        background: rgba(0, 0, 0, 0.03);      }      *,      /deep/ * {        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;      }    `,  ],})export class LayoutComponent {}","projects/example-app/src/app/core/components/nav-item.component.ts":"import { Component, Input, Output, EventEmitter } from '@angular/core';@Component({  selector: 'bc-nav-item',  template: `    <a mat-list-item [routerLink]=\"routerLink\" (click)=\"navigate.emit()\">      <mat-icon mat-list-icon>{{ icon }}</mat-icon>      <span mat-line><ng-content></ng-content></span>      <span mat-line class=\"secondary\">{{ hint }}</span>    </a>  `,  styles: [    `      .secondary {        color: rgba(0, 0, 0, 0.54);      }    `,  ],})export class NavItemComponent {  @Input() icon = '';  @Input() hint = '';  @Input() routerLink: string | any[] = '/';  @Output() navigate = new EventEmitter();}","projects/example-app/src/app/core/components/sidenav.component.ts":"import { Component, EventEmitter, Input, Output } from '@angular/core';@Component({  selector: 'bc-sidenav',  template: `    <mat-sidenav #sidenav [opened]=\"open\" (keydown.escape)=\"sidenav.close()\" (closedStart)=\"closeMenu.emit()\" disableClose>      <mat-nav-list>        <ng-content></ng-content>      </mat-nav-list>    </mat-sidenav>  `,  styles: [    `      mat-sidenav {        width: 300px;      }    `,  ],})export class SidenavComponent {  @Input() open = false;  @Output() closeMenu = new EventEmitter();}","projects/example-app/src/app/core/components/toolbar.component.ts":"import { Component, Output, EventEmitter } from '@angular/core';@Component({  selector: 'bc-toolbar',  template: `    <mat-toolbar color=\"primary\">      <button mat-icon-button (click)=\"openMenu.emit()\">        <mat-icon>menu</mat-icon>      </button>      <ng-content></ng-content>    </mat-toolbar>  `,})export class ToolbarComponent {  @Output() openMenu = new EventEmitter();}","projects/example-app/src/app/core/containers/app.component.ts":"import { ChangeDetectionStrategy, Component } from '@angular/core';import { select, Store } from '@ngrx/store';import { Observable } from 'rxjs';import * as AuthActions from '../../auth/actions/auth.actions';import * as fromAuth from '../../auth/reducers';import * as fromRoot from '../../reducers';import * as LayoutActions from '../actions/layout.actions';@Component({  selector: 'bc-app',  changeDetection: ChangeDetectionStrategy.OnPush,  template: `    <bc-layout>      <bc-sidenav [open]=\"showSidenav$ | async\" (closeMenu)=\"closeSidenav()\">        <bc-nav-item (navigate)=\"closeSidenav()\" *ngIf=\"loggedIn$ | async\" routerLink=\"/\" icon=\"book\" hint=\"View your book collection\">          My Collection        </bc-nav-item>        <bc-nav-item (navigate)=\"closeSidenav()\" *ngIf=\"loggedIn$ | async\" routerLink=\"/books/find\" icon=\"search\" hint=\"Find your next book!\">          Browse Books        </bc-nav-item>        <bc-nav-item (navigate)=\"closeSidenav()\" *ngIf=\"!(loggedIn$ | async)\">          Sign In        </bc-nav-item>        <bc-nav-item (navigate)=\"logout()\" *ngIf=\"loggedIn$ | async\">          Sign Out        </bc-nav-item>      </bc-sidenav>      <bc-toolbar (openMenu)=\"openSidenav()\">        Book Collection      </bc-toolbar>      <router-outlet></router-outlet>    </bc-layout>  `,})export class AppComponent {  showSidenav$: Observable<boolean>;  loggedIn$: Observable<boolean>;  constructor(private store: Store<fromRoot.State>) {    /**     * Selectors can be applied with the `select` operator which passes the state     * tree to the provided selector     */    this.showSidenav$ = this.store.pipe(select(fromRoot.getShowSidenav));    this.loggedIn$ = this.store.pipe(select(fromAuth.getLoggedIn));  }  closeSidenav() {    /**     * All state updates are handled through dispatched actions in 'container'     * components. This provides a clear, reproducible history of state     * updates and user interaction through the life of our     * application.     */    this.store.dispatch(new LayoutActions.CloseSidenav());  }  openSidenav() {    this.store.dispatch(new LayoutActions.OpenSidenav());  }  logout() {    this.closeSidenav();    this.store.dispatch(new AuthActions.Logout());  }}","projects/example-app/src/app/core/containers/not-found-page.component.ts":"import { Component, ChangeDetectionStrategy } from '@angular/core';@Component({  selector: 'bc-not-found-page',  changeDetection: ChangeDetectionStrategy.OnPush,  template: `    <mat-card>      <mat-card-title>404: Not Found</mat-card-title>      <mat-card-content>        <p>Hey! It looks like this page doesn't exist yet.</p>      </mat-card-content>      <mat-card-actions>        <button mat-raised-button color=\"primary\" routerLink=\"/\">Take Me Home</button>      </mat-card-actions>    </mat-card>  `,  styles: [    `      :host {        text-align: center;      }    `,  ],})export class NotFoundPageComponent {}","projects/example-app/src/app/core/core.module.ts":"import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { RouterModule } from '@angular/router';import { AppComponent } from './containers/app.component';import { NotFoundPageComponent } from './containers/not-found-page.component';import { LayoutComponent } from './components/layout.component';import { NavItemComponent } from './components/nav-item.component';import { SidenavComponent } from './components/sidenav.component';import { ToolbarComponent } from './components/toolbar.component';import { MaterialModule } from '../material';export const COMPONENTS = [  AppComponent,  NotFoundPageComponent,  LayoutComponent,  NavItemComponent,  SidenavComponent,  ToolbarComponent,];@NgModule({  imports: [CommonModule, RouterModule, MaterialModule],  declarations: COMPONENTS,  exports: COMPONENTS,})export class CoreModule {}","projects/example-app/src/app/core/reducers/layout.reducer.ts":"import {  LayoutActionTypes,  LayoutActionsUnion,} from '../actions/layout.actions';export interface State {  showSidenav: boolean;}const initialState: State = {  showSidenav: false,};export function reducer(  state: State = initialState,  action: LayoutActionsUnion): State {  switch (action.type) {    case LayoutActionTypes.CloseSidenav:      return {        showSidenav: false,      };    case LayoutActionTypes.OpenSidenav:      return {        showSidenav: true,      };    default:      return state;  }}export const getShowSidenav = (state: State) => state.showSidenav;","projects/example-app/src/app/core/services/google-books.service.ts":"import { HttpClient } from '@angular/common/http';import { Injectable } from '@angular/core';import { Observable } from 'rxjs';import { map } from 'rxjs/operators';import { Book } from '../../books/models/book';@Injectable({  providedIn: 'root',})export class GoogleBooksService {  private API_PATH = 'https://www.googleapis.com/books/v1/volumes';  constructor(private http: HttpClient) {}  searchBooks(queryTitle: string): Observable<Book[]> {    return this.http      .get<{ items: Book[] }>(`${this.API_PATH}?q=${queryTitle}`)      .pipe(map(books => books.items || []));  }  retrieveBook(volumeId: string): Observable<Book> {    return this.http.get<Book>(`${this.API_PATH}/${volumeId}`);  }}","projects/example-app/src/app/db.ts":"import { DBSchema } from '@ngrx/db';/** * ngrx/db uses a simple schema config object to initialize stores in IndexedDB. */export const schema: DBSchema = {  version: 1,  name: 'books_app',  stores: {    books: {      autoIncrement: true,      primaryKey: 'id',    },  },};","projects/example-app/src/app/index.ts":"export * from './app.module';","projects/example-app/src/app/material/index.ts":"export * from './material.module';","projects/example-app/src/app/material/material.module.ts":"import { NgModule } from '@angular/core';import {  MatInputModule,  MatCardModule,  MatButtonModule,  MatSidenavModule,  MatListModule,  MatIconModule,  MatToolbarModule,  MatProgressSpinnerModule,} from '@angular/material';@NgModule({  imports: [    MatInputModule,    MatCardModule,    MatButtonModule,    MatSidenavModule,    MatListModule,    MatIconModule,    MatToolbarModule,    MatProgressSpinnerModule,  ],  exports: [    MatInputModule,    MatCardModule,    MatButtonModule,    MatSidenavModule,    MatListModule,    MatIconModule,    MatToolbarModule,    MatProgressSpinnerModule,  ],})export class MaterialModule {}","projects/example-app/src/app/reducers/index.ts":"import {  ActionReducerMap,  createSelector,  createFeatureSelector,  ActionReducer,  MetaReducer,} from '@ngrx/store';import { environment } from '../../environments/environment';import * as fromRouter from '@ngrx/router-store';/** * storeFreeze prevents state from being mutated. When mutation occurs, an * exception will be thrown. This is useful during development mode to * ensure that none of the reducers accidentally mutates the state. */import { storeFreeze } from 'ngrx-store-freeze';/** * Every reducer module's default export is the reducer function itself. In * addition, each module should export a type or interface that describes * the state of the reducer plus any selector functions. The `* as` * notation packages up all of the exports into a single object. */import * as fromLayout from '../core/reducers/layout.reducer';/** * As mentioned, we treat each reducer like a table in a database. This means * our top level state interface is just a map of keys to inner state types. */export interface State {  layout: fromLayout.State;  router: fromRouter.RouterReducerState;}/** * Our state is composed of a map of action reducer functions. * These reducer functions are called with each dispatched action * and the current or initial state and return a new immutable state. */export const reducers: ActionReducerMap<State> = {  layout: fromLayout.reducer,  router: fromRouter.routerReducer,};// console.log all actionsexport function logger(reducer: ActionReducer<State>): ActionReducer<State> {  return function(state: State, action: any): State {    console.log('state', state);    console.log('action', action);    return reducer(state, action);  };}/** * By default, @ngrx/store uses combineReducers with the reducer map to compose * the root meta-reducer. To add more meta-reducers, provide an array of meta-reducers * that will be composed to form the root meta-reducer. */export const metaReducers: MetaReducer<State>[] = !environment.production  ? [logger, storeFreeze]  : [];/** * Layout Reducers */export const getLayoutState = createFeatureSelector<State, fromLayout.State>(  'layout');export const getShowSidenav = createSelector(  getLayoutState,  fromLayout.getShowSidenav);","projects/example-app/src/app/shared/pipes/add-commas.pipe.ts":"import { Pipe, PipeTransform } from '@angular/core';@Pipe({ name: 'bcAddCommas' })export class AddCommasPipe implements PipeTransform {  transform(authors: null | string[]) {    if (!authors) {      return 'Author Unknown';    }    switch (authors.length) {      case 0:        return 'Author Unknown';      case 1:        return authors[0];      case 2:        return authors.join(' and ');      default:        const last = authors[authors.length - 1];        const remaining = authors.slice(0, -1);        return `${remaining.join(', ')}, and ${last}`;    }  }}","projects/example-app/src/app/shared/pipes/ellipsis.pipe.ts":"import { Pipe, PipeTransform } from '@angular/core';@Pipe({ name: 'bcEllipsis' })export class EllipsisPipe implements PipeTransform {  transform(str: string, strLength: number = 250) {    const withoutHtml = str.replace(/(<([^>]+)>)/gi, '');    if (str.length >= strLength) {      return `${withoutHtml.slice(0, strLength)}...`;    }    return withoutHtml;  }}","projects/example-app/src/app/shared/pipes/index.ts":"import { NgModule } from '@angular/core';import { AddCommasPipe } from './add-commas.pipe';import { EllipsisPipe } from './ellipsis.pipe';export const PIPES = [AddCommasPipe, EllipsisPipe];@NgModule({  declarations: PIPES,  exports: PIPES,})export class PipesModule {}","projects/example-app/src/environments/environment.prod.ts":"export const environment = {  production: true,};","projects/example-app/src/environments/environment.ts":"// The file contents for the current environment will overwrite these during build.// The build system defaults to the dev environment which uses `environment.ts`, but if you do// `ng build --env=prod` then `environment.prod.ts` will be used instead.// The list of which env maps to which file can be found in `angular-cli.json`.export const environment = {  production: false,};","projects/example-app/src/favicon.ico":"\u0000\u0000\u0001\u0000\u0002\u0000\u0010\u0010\u0000\u0000\u0000\u0000 \u0000h\u0004\u0000\u0000&\u0000\u0000\u0000  \u0000\u0000\u0000\u0000 \u0000�\u0010\u0000\u0000�\u0004\u0000\u0000(\u0000\u0000\u0000\u0010\u0000\u0000\u0000 \u0000\u0000\u0000\u0001\u0000 \u0000\u0000\u0000\u0000\u0000@\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�U61��0-��2.�;���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�971��71��71��0-��0-��1-��3/�#���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�!71�71��71��71��71��0-��0-��0-��0-��1-��3/�\u000f���\u0001���\u0001���\u000171�U71��OI��VQ��82��71��71��0-��0-��0-��UR��KH��0-��2.�=���\u0001���\u000171�71����������mh��71��71��0-��0-��[X����������0-��1.�{���\u0001���\u000171�71��C=����������71��71��0-��0-����������85��0-��0-�����\u0001���\u000171��71��71����������������������������������0-��0-��1-�����\u0001���\u000171��71��71��QL��������������������������?<��0-��0-��0-�����\u0001���\u000171��71��71��71����������;5��:7����������0-��0-��0-��0-�����\u000171�#71��71��71��71��d_������}y����������IG��0-��0-��0-��0-��4/�\u000f71�M71��71��71��71��71������������������0-��0-��0-��0-��0-��3/�A71�k71��71��71��71��71��zv����������VS��0-��0-��0-��0-��0-��2.�e71�}71��71��71��71��71��93����������0-��0-��0-��0-��0-��0-��1.�{71�A71��71��71��71��71��71������db��0-��0-��0-��0-��0-��1-��0-�E���\u0001���\u000171�)71�71��71��71��=7��0-��0-��0-��0-��1-��3/�/���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�A71�61��0-��0-��3.�9���\u0001���\u0001���\u0001���\u0001���\u0001\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��\u0000\u0000��(\u0000\u0000\u0000 \u0000\u0000\u0000@\u0000\u0000\u0000\u0001\u0000 \u0000\u0000\u0000\u0000\u0000�\u0010\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�61��2.��3/�?���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�_71��71��71��0-��0-��2.��3/�\u001f���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�;71��71��71��71��71��0-��0-��0-��0-��3.ŭ4/�\u000b���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�\u001d71��71��71��71��71��71��71��0-��0-��0-��0-��0-��1.��3/ǉ���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�\t71�71��71��71��71��71��71��71��71��0-��0-��0-��0-��0-��0-��0-��1.��3/�_���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�71��71��71��71��71��71��71��71��71��71��0-��0-��0-��0-��0-��0-��0-��0-��0-��2.��3/�;���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�Y71��71��71��71��71��71��71��71��71��71��71��71��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��2.��3/�\u001d���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171��71��71��XS��wr��vr��vr��<7��71��71��71��71��71��0-��0-��0-��0-��0-��0-��wu��~|��~|��NK��0-��0-��2.�����\u0001���\u0001���\u0001���\u0001���\u0001���\u000171��71��71��UP��������������{w��71��71��71��71��71��0-��0-��0-��0-��0-��YW��������������DB��0-��0-��1.�����\u0001���\u0001���\u0001���\u0001���\u000171�\u001b71��71��71��71������������������71��71��71��71��71��0-��0-��0-��0-��0-������������������0-��0-��0-��1.�����\u0001���\u0001���\u0001���\u0001���\u000171�O71��71��71��71��hc��������������SN��71��71��71��71��0-��0-��0-��0-��B?��������������PM��0-��0-��0-��0-��50�\u0003���\u0001���\u0001���\u0001���\u000171�}71��71��71��71��71������������������71��71��71��71��0-��0-��0-��0-������������������0-��0-��0-��0-��0-��3/�3���\u0001���\u0001���\u0001���\u000171�71��71��71��71��71��~{����������������������������������������������������������][��0-��0-��0-��0-��0-��3/�i���\u0001���\u0001���\u0001���\u000171��71��71��71��71��71��;5����������������������������������������������������������0-��0-��0-��0-��0-��0-��3/Ǘ���\u0001���\u0001���\u0001���\u000171��71��71��71��71��71��71������������������������������������������������������mk��0-��0-��0-��0-��0-��0-��2.Ž���\u0001���\u0001���\u0001���\u000171��71��71��71��71��71��71��D>������������������ie��ie��db��db������������������1.��0-��0-��0-��0-��0-��0-��2.�����\u0001���\u0001���\u0001���\u000171��71��71��71��71��71��71��71������������������71��71��0-��0-��������������|z��0-��0-��0-��0-��0-��0-��0-��2.�����\u0001���\u0001���\u0001���\u000171��71��71��71��71��71��71��71��RL��������������JD��71��0-��XU��������������52��0-��0-��0-��0-��0-��0-��0-��1.�����\u0001���\u0001���\u000171�+71��71��71��71��71��71��71��71��71������������������71��0-������������������0-��0-��0-��0-��0-��0-��0-��0-��0-��50�\u0005���\u0001���\u000171�]71��71��71��71��71��71��71��71��71��ea��������������:4��QO��������������:7��0-��0-��0-��0-��0-��0-��0-��0-��0-��4/�5���\u0001���\u000171�71��71��71��71��71��71��71��71��71��71��������������wr������������������0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��3/�k���\u0001���\u000171�71��71��71��71��71��71��71��71��71��71��zv��������������������������C@��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��3/Ǘ���\u0001���\u000171��71��71��71��71��71��71��71��71��71��71��:4��������������������������0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��2.Ž���\u0001���\u000171��71��71��71��71��71��71��71��71��71��71��71����������������������MK��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��2.�����\u0001���\u000171��71��71��71��71��71��71��71��71��71��71��71��B<������������������0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��2.�����\u0001���\u000171��71��71��71��71��71��71��71��71��71��71��71��71��������������[Y��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��1.�����\u0001���\u000171��71��71��71��71��71��71��71��71��71��71��71��71��OJ����������0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-�����\u0001���\u000171�\u000571�y71��71��71��71��71��71��71��71��71��71��71��71������jg��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��0-��2.��3/Ɠ4/�\u0015���\u0001���\u0001���\u0001���\u0001���\u000171�\u001371�71��71��71��71��71��71��71��71��71��PK��1.��0-��0-��0-��0-��0-��0-��0-��0-��2.��3/Ǜ3/�\u001d���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�)71�71��71��71��71��71��71��71��0-��0-��0-��0-��0-��0-��1.��3/ƥ4/�'���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�C71�71��71��71��71��0-��0-��0-��1.��3.ů3/�1���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u000171�a71��61��1.��2.ŷ3/�=���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001���\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000","projects/example-app/src/index.html":"<!doctype html><html><head>  <meta charset=\"utf-8\">  <title>Book Collection</title>  <base href=\"/\">  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">  <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"></head><body>  <bc-app>Loading...</bc-app></body></html>","projects/example-app/src/main.ts":"import './polyfills.ts';import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';import { enableProdMode } from '@angular/core';import { environment } from './environments/environment';import { AppModule } from './app/app.module';if (environment.production) {  enableProdMode();}platformBrowserDynamic().bootstrapModule(AppModule);","projects/example-app/src/polyfills.ts":"// This file includes polyfills needed by Angular and is loaded before// the app. You can add your own extra polyfills to this file.import 'core-js/es6/symbol';import 'core-js/es6/object';import 'core-js/es6/function';import 'core-js/es6/parse-int';import 'core-js/es6/parse-float';import 'core-js/es6/number';import 'core-js/es6/math';import 'core-js/es6/string';import 'core-js/es6/date';import 'core-js/es6/array';import 'core-js/es6/regexp';import 'core-js/es6/map';import 'core-js/es6/set';import 'core-js/es6/reflect';import 'core-js/es7/reflect';import 'zone.js/dist/zone';import 'hammerjs';","projects/example-app/src/setup-jest.ts":"import 'jest-preset-angular';(global as any)['CSS'] = null;/** * ISSUE: https://github.com/angular/material2/issues/7101 * Workaround for JSDOM missing transform property */Object.defineProperty(document.body.style, 'transform', {  value: () => {    return {      enumerable: true,      configurable: true,    };  },});","projects/example-app/src/styles.css":"/* You can add global styles to this file, and also import other style files */@import \"~@angular/material/prebuilt-themes/deeppurple-amber.css\";* {  box-sizing: border-box;}html {  -webkit-font-smoothing: antialiased;  -ms-overflow-style: none;  overflow: auto;}.mat-progress-spinner svg {  width: 30px !important;  height: 30px !important;}","projects/example-app/src/test.ts":"// This file is required by karma.conf.js and loads recursively all the .spec and framework filesimport 'zone.js/dist/long-stack-trace-zone';import 'zone.js/dist/proxy.js';import 'zone.js/dist/sync-test';import 'zone.js/dist/jasmine-patch';import 'zone.js/dist/async-test';import 'zone.js/dist/fake-async-test';import { getTestBed } from '@angular/core/testing';import {  BrowserDynamicTestingModule,  platformBrowserDynamicTesting,} from '@angular/platform-browser-dynamic/testing';// fixes typing errors in Atom editorimport {} from 'jasmine';// Unfortunately there's no typing for the `__karma__` variable. Just declare it as any.declare var __karma__: any;declare var require: any;// Prevent Karma from running prematurely.__karma__.loaded = function() {};// First, initialize the Angular testing environment.getTestBed().initTestEnvironment(  BrowserDynamicTestingModule,  platformBrowserDynamicTesting());// Then we find all the tests.const context = require.context('./', true, /\\.spec\\.ts$/);// And load the modules.context.keys().map(context);// Finally, start Karma to run the tests.__karma__.start();","projects/example-app/tsconfig.app.json":"{  \"compilerOptions\": {    \"sourceMap\": true,    \"declaration\": false,    \"moduleResolution\": \"node\",    \"emitDecoratorMetadata\": true,    \"experimentalDecorators\": true,    \"lib\": [\"es2017\", \"dom\"],    \"outDir\": \"../out-tsc/app\",    \"target\": \"es5\",    \"module\": \"es2015\",    \"types\": [],    \"baseUrl\": \".\",    \"paths\": {      \"@ngrx/effects\": [\"../../modules/effects\"],      \"@ngrx/store\": [\"../../modules/store\"],      \"@ngrx/store-devtools\": [\"../../modules/store-devtools\"],      \"@ngrx/router-store\": [\"../../modules/router-store\"],      \"@ngrx/entity\": [\"../../modules/entity\"],      \"@ngrx/schematics\": [\"../../modules/schematics\"]    }  },  \"exclude\": [    \"../../node_modules\",    \"test.ts\",    \"**/*.spec.ts\",    \"**/setup-jest.ts\"  ]}","projects/example-app/tsconfig.spec.json":"{  \"compilerOptions\": {    \"sourceMap\": true,    \"declaration\": false,    \"moduleResolution\": \"node\",    \"emitDecoratorMetadata\": true,    \"experimentalDecorators\": true,    \"lib\": [\"es2017\", \"dom\"],    \"outDir\": \"../out-tsc/spec\",    \"module\": \"commonjs\",    \"target\": \"es6\",    \"types\": [\"jasmine\", \"node\"],    \"baseUrl\": \".\",    \"rootDir\": \"./\"  },  \"files\": [\"test.ts\", \"polyfills.ts\"],  \"include\": [\"**/*.spec.ts\"]}","projects/example-app/tslint.json":"{  \"rules\": {    \"class-name\": true,    \"no-duplicate-variable\": true,    \"no-eval\": false,    \"no-internal-module\": true,    \"no-var-keyword\": true,    \"triple-equals\": [false, \"allow-null-check\"],    \"variable-name\": [true, \"ban-keywords\", \"allow-leading-underscore\"]  }}"},
        title: 'NgRx Example App',
        description: 'NgRx example application with common patterns and best practices',
        template: 'angular-cli',
        tags: ['angular', 'ngrx', 'redux', 'example'],
        dependencies: {"@angular/animations":"^6.1.0","@angular/bazel":"^6.1.0","@angular/cdk":"^6.4.2","@angular/cli":"^6.1.2","@angular/common":"^6.1.0","@angular/compiler":"^6.1.0","@angular/compiler-cli":"^6.1.0","@angular/core":"^6.1.0","@angular/forms":"^6.1.0","@angular/http":"^6.1.0","@angular/material":"^6.4.2","@angular/platform-browser":"^6.1.0","@angular/platform-browser-dynamic":"^6.1.0","@angular/platform-server":"^6.1.0","@angular/router":"^6.1.0","@ngrx/db":"^2.2.0-beta.0","core-js":"^2.5.4","hammerjs":"^2.0.8","ngrx-store-freeze":"^0.2.2","opencollective":"^1.0.3","rxjs":"^6.2.2","rxjs-compat":"^6.2.2","zone.js":"^0.8.26","@ngrx/effects":"6.1.0","@ngrx/entity":"6.1.0","@ngrx/router-store":"6.1.0","@ngrx/schematics":"6.1.0","@ngrx/store":"6.1.0","@ngrx/store-devtools":"6.1.0"}
      };

      StackBlitzSDK.openProject(project, { newWindow: false });
    </script>
    </body>
    </html>
  