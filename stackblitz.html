
    <html>
    <head>
      <script src="https://unpkg.com/@stackblitz/sdk/bundles/sdk.umd.js"></script>
    </head>
    <body>
    <script>
      const project = {
        files: {"angular.json":"{\n  \"$schema\":\n    \"./node_modules/@angular-devkit/core/src/workspace/workspace-schema.json\",\n  \"version\": 1,\n  \"newProjectRoot\": \"projects\",\n  \"defaultProject\": \"example-app\",\n  \"projects\": {\n    \"example-app\": {\n      \"root\": \"\",\n      \"sourceRoot\": \"projects/example-app/src\",\n      \"projectType\": \"application\",\n      \"prefix\": \"bc\",\n      \"schematics\": {},\n      \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"projects/example-app/dist\",\n            \"index\": \"projects/example-app/src/index.html\",\n            \"main\": \"projects/example-app/src/main.ts\",\n            \"polyfills\": \"projects/example-app/src/polyfills.ts\",\n            \"tsConfig\": \"projects/example-app/tsconfig.app.json\",\n            \"assets\": [\n              \"projects/example-app/src/favicon.ico\",\n              \"projects/example-app/src/assets\"\n            ],\n            \"styles\": [\"projects/example-app/src/styles.css\"],\n            \"scripts\": []\n          },\n          \"configurations\": {\n            \"production\": {\n              \"fileReplacements\": [\n                {\n                  \"replace\":\n                    \"projects/example-app/src/environments/environment.ts\",\n                  \"with\":\n                    \"projects/example-app/src/environments/environment.prod.ts\"\n                }\n              ],\n              \"optimization\": true,\n              \"outputHashing\": \"all\",\n              \"sourceMap\": false,\n              \"extractCss\": true,\n              \"namedChunks\": false,\n              \"aot\": true,\n              \"extractLicenses\": true,\n              \"vendorChunk\": false,\n              \"buildOptimizer\": true\n            }\n          }\n        },\n        \"serve\": {\n          \"builder\": \"@angular-devkit/build-angular:dev-server\",\n          \"options\": {\n            \"browserTarget\": \"example-app:build\"\n          },\n          \"configurations\": {\n            \"production\": {\n              \"browserTarget\": \"example-app:build:production\"\n            }\n          }\n        },\n        \"extract-i18n\": {\n          \"builder\": \"@angular-devkit/build-angular:extract-i18n\",\n          \"options\": {\n            \"browserTarget\": \"example-app:build\"\n          }\n        },\n        \"test\": {\n          \"builder\": \"@angular-devkit/build-angular:karma\",\n          \"options\": {\n            \"main\": \"projects/example-app/src/test.ts\",\n            \"polyfills\": \"projects/example-app/src/polyfills.ts\",\n            \"tsConfig\": \"projects/example-app/tsconfig.spec.json\",\n            \"karmaConfig\": \"projects/example-app/karma.conf.js\",\n            \"styles\": [\"projects/example-app/src/styles.css\"],\n            \"scripts\": [],\n            \"assets\": [\n              \"projects/example-app/src/favicon.ico\",\n              \"projects/example-app/src/assets\"\n            ]\n          }\n        },\n        \"lint\": {\n          \"builder\": \"@angular-devkit/build-angular:tslint\",\n          \"options\": {\n            \"tsConfig\": [\n              \"projects/example-app/tsconfig.app.json\",\n              \"projects/example-app/tsconfig.spec.json\"\n            ],\n            \"exclude\": [\"**/node_modules/**\"]\n          }\n        }\n      }\n    },\n    \"example-app-e2e\": {\n      \"root\": \"projects/example-app-e2e/\",\n      \"projectType\": \"application\",\n      \"architect\": {\n        \"e2e\": {\n          \"builder\": \"@angular-devkit/build-angular:protractor\",\n          \"options\": {\n            \"protractorConfig\": \"projects/example-app-e2e/protractor.conf.js\",\n            \"devServerTarget\": \"example-app:serve\"\n          },\n          \"configurations\": {\n            \"production\": {\n              \"devServerTarget\": \"example-app:serve:production\"\n            }\n          }\n        },\n        \"lint\": {\n          \"builder\": \"@angular-devkit/build-angular:tslint\",\n          \"options\": {\n            \"tsConfig\": \"projects/example-app-e2e/tsconfig.e2e.json\",\n            \"exclude\": [\"**/node_modules/**\"]\n          }\n        }\n      }\n    }\n  },\n  \"schematics\": {\n    \"@schematics/angular:component\": {\n      \"inlineStyle\": true,\n      \"inlineTemplate\": true,\n      \"flat\": true,\n      \"spec\": false,\n      \"prefix\": \"bc\",\n      \"styleext\": \"css\"\n    },\n    \"@schematics/angular:directive\": {\n      \"prefix\": \"bc\"\n    }\n  }\n}\n","projects/example-app/src/app/app-routing.module.ts":"import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { AuthGuard } from './auth/services/auth-guard.service';\nimport { NotFoundPageComponent } from './core/containers/not-found-page.component';\n\nexport const routes: Routes = [\n  { path: '', redirectTo: '/books', pathMatch: 'full' },\n  {\n    path: 'books',\n    loadChildren: './books/books.module#BooksModule',\n    canActivate: [AuthGuard],\n  },\n  { path: '**', component: NotFoundPageComponent },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes, { useHash: true })],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n","projects/example-app/src/app/app.module.ts":"import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { HttpClientModule } from '@angular/common/http';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { DBModule } from '@ngrx/db';\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\n\nimport { CoreModule } from './core/core.module';\nimport { AuthModule } from './auth/auth.module';\n\nimport { reducers, metaReducers } from './reducers';\nimport { schema } from './db';\n\nimport { AppComponent } from './core/containers/app.component';\nimport { environment } from '../environments/environment';\nimport { AppRoutingModule } from './app-routing.module';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    BrowserModule,\n    BrowserAnimationsModule,\n    HttpClientModule,\n    AuthModule,\n    AppRoutingModule,\n\n    /**\n     * StoreModule.forRoot is imported once in the root module, accepting a reducer\n     * function or object map of reducer functions. If passed an object of\n     * reducers, combineReducers will be run creating your application\n     * meta-reducer. This returns all providers for an @ngrx/store\n     * based application.\n     */\n    StoreModule.forRoot(reducers, { metaReducers }),\n\n    /**\n     * @ngrx/router-store keeps router state up-to-date in the store.\n     */\n    StoreRouterConnectingModule.forRoot(),\n\n    /**\n     * Store devtools instrument the store retaining past versions of state\n     * and recalculating new states. This enables powerful time-travel\n     * debugging.\n     *\n     * To use the debugger, install the Redux Devtools extension for either\n     * Chrome or Firefox\n     *\n     * See: https://github.com/zalmoxisus/redux-devtools-extension\n     */\n    StoreDevtoolsModule.instrument({\n      name: 'NgRx Book Store App',\n      logOnly: environment.production,\n    }),\n\n    /**\n     * EffectsModule.forRoot() is imported once in the root module and\n     * sets up the effects class to be initialized immediately when the\n     * application starts.\n     *\n     * See: https://github.com/ngrx/platform/blob/master/docs/effects/api.md#forroot\n     */\n    EffectsModule.forRoot([]),\n\n    /**\n     * `provideDB` sets up @ngrx/db with the provided schema and makes the Database\n     * service available.\n     */\n    DBModule.provideDB(schema),\n\n    CoreModule,\n  ],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n","projects/example-app/src/app/auth/actions/auth.actions.ts":"import { Action } from '@ngrx/store';\nimport { User, Authenticate } from '../models/user';\n\nexport enum AuthActionTypes {\n  Login = '[Auth] Login',\n  Logout = '[Auth] Logout',\n  LoginSuccess = '[Auth] Login Success',\n  LoginFailure = '[Auth] Login Failure',\n  LoginRedirect = '[Auth] Login Redirect',\n}\n\nexport class Login implements Action {\n  readonly type = AuthActionTypes.Login;\n\n  constructor(public payload: Authenticate) {}\n}\n\nexport class LoginSuccess implements Action {\n  readonly type = AuthActionTypes.LoginSuccess;\n\n  constructor(public payload: { user: User }) {}\n}\n\nexport class LoginFailure implements Action {\n  readonly type = AuthActionTypes.LoginFailure;\n\n  constructor(public payload: any) {}\n}\n\nexport class LoginRedirect implements Action {\n  readonly type = AuthActionTypes.LoginRedirect;\n}\n\nexport class Logout implements Action {\n  readonly type = AuthActionTypes.Logout;\n}\n\nexport type AuthActionsUnion =\n  | Login\n  | LoginSuccess\n  | LoginFailure\n  | LoginRedirect\n  | Logout;\n","projects/example-app/src/app/auth/auth-routing.module.ts":"import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { LoginPageComponent } from './containers/login-page.component';\n\nconst routes: Routes = [{ path: 'login', component: LoginPageComponent }];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class AuthRoutingModule {}\n","projects/example-app/src/app/auth/auth.module.ts":"import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { LoginPageComponent } from './containers/login-page.component';\nimport { LoginFormComponent } from './components/login-form.component';\n\nimport { AuthEffects } from './effects/auth.effects';\nimport { reducers } from './reducers';\nimport { MaterialModule } from '../material';\nimport { AuthRoutingModule } from './auth-routing.module';\n\nexport const COMPONENTS = [LoginPageComponent, LoginFormComponent];\n\n@NgModule({\n  imports: [\n    CommonModule,\n    ReactiveFormsModule,\n    MaterialModule,\n    AuthRoutingModule,\n    StoreModule.forFeature('auth', reducers),\n    EffectsModule.forFeature([AuthEffects]),\n  ],\n  declarations: COMPONENTS,\n})\nexport class AuthModule {}\n","projects/example-app/src/app/auth/components/login-form.component.ts":"import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\nimport { Authenticate } from '../models/user';\n\n@Component({\n  selector: 'bc-login-form',\n  template: `\n    <mat-card>\n      <mat-card-title>Login</mat-card-title>\n      <mat-card-content>\n        <form [formGroup]=\"form\" (ngSubmit)=\"submit()\">\n          <p>\n            <mat-form-field>\n              <input type=\"text\" matInput placeholder=\"Username\" formControlName=\"username\">\n            </mat-form-field>\n          </p>\n\n          <p>\n            <mat-form-field>\n              <input type=\"password\" matInput placeholder=\"Password\" formControlName=\"password\">\n            </mat-form-field>\n          </p>\n\n          <p *ngIf=\"errorMessage\" class=\"loginError\">\n            {{ errorMessage }}\n          </p>\n\n          <p class=\"loginButtons\">\n            <button type=\"submit\" mat-button>Login</button>\n          </p>\n\n        </form>\n      </mat-card-content>\n    </mat-card>\n  `,\n  styles: [\n    `\n      :host {\n        display: flex;\n        justify-content: center;\n        margin: 72px 0;\n      }\n\n      .mat-form-field {\n        width: 100%;\n        min-width: 300px;\n      }\n\n      mat-card-title,\n      mat-card-content {\n        display: flex;\n        justify-content: center;\n      }\n\n      .loginError {\n        padding: 16px;\n        width: 300px;\n        color: white;\n        background-color: red;\n      }\n\n      .loginButtons {\n        display: flex;\n        flex-direction: row;\n        justify-content: flex-end;\n      }\n    `,\n  ],\n})\nexport class LoginFormComponent implements OnInit {\n  @Input()\n  set pending(isPending: boolean) {\n    if (isPending) {\n      this.form.disable();\n    } else {\n      this.form.enable();\n    }\n  }\n\n  @Input() errorMessage: string | null;\n\n  @Output() submitted = new EventEmitter<Authenticate>();\n\n  form: FormGroup = new FormGroup({\n    username: new FormControl(''),\n    password: new FormControl(''),\n  });\n\n  constructor() {}\n\n  ngOnInit() {}\n\n  submit() {\n    if (this.form.valid) {\n      this.submitted.emit(this.form.value);\n    }\n  }\n}\n","projects/example-app/src/app/auth/containers/login-page.component.ts":"import { Component, OnInit } from '@angular/core';\nimport { Store, select } from '@ngrx/store';\nimport { Authenticate } from '../models/user';\nimport * as fromAuth from '../reducers';\nimport * as AuthActions from '../actions/auth.actions';\n\n@Component({\n  selector: 'bc-login-page',\n  template: `\n    <bc-login-form\n      (submitted)=\"onSubmit($event)\"\n      [pending]=\"pending$ | async\"\n      [errorMessage]=\"error$ | async\">\n    </bc-login-form>\n  `,\n  styles: [],\n})\nexport class LoginPageComponent implements OnInit {\n  pending$ = this.store.pipe(select(fromAuth.getLoginPagePending));\n  error$ = this.store.pipe(select(fromAuth.getLoginPageError));\n\n  constructor(private store: Store<fromAuth.State>) {}\n\n  ngOnInit() {}\n\n  onSubmit($event: Authenticate) {\n    this.store.dispatch(new AuthActions.Login($event));\n  }\n}\n","projects/example-app/src/app/auth/effects/auth.effects.ts":"import { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Actions, Effect, ofType } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { catchError, exhaustMap, map, tap } from 'rxjs/operators';\n\nimport {\n  AuthActionTypes,\n  Login,\n  LoginFailure,\n  LoginSuccess,\n} from '../actions/auth.actions';\nimport { Authenticate } from '../models/user';\nimport { AuthService } from '../services/auth.service';\n\n@Injectable()\nexport class AuthEffects {\n  @Effect()\n  login$ = this.actions$.pipe(\n    ofType<Login>(AuthActionTypes.Login),\n    map(action => action.payload),\n    exhaustMap((auth: Authenticate) =>\n      this.authService.login(auth).pipe(\n        map(user => new LoginSuccess({ user })),\n        catchError(error => of(new LoginFailure(error)))\n      )\n    )\n  );\n\n  @Effect({ dispatch: false })\n  loginSuccess$ = this.actions$.pipe(\n    ofType(AuthActionTypes.LoginSuccess),\n    tap(() => this.router.navigate(['/']))\n  );\n\n  @Effect({ dispatch: false })\n  loginRedirect$ = this.actions$.pipe(\n    ofType(AuthActionTypes.LoginRedirect, AuthActionTypes.Logout),\n    tap(authed => {\n      this.router.navigate(['/login']);\n    })\n  );\n\n  constructor(\n    private actions$: Actions,\n    private authService: AuthService,\n    private router: Router\n  ) {}\n}\n","projects/example-app/src/app/auth/models/user.ts":"export interface Authenticate {\n  username: string;\n  password: string;\n}\n\nexport interface User {\n  name: string;\n}\n","projects/example-app/src/app/auth/reducers/auth.reducer.ts":"import { AuthActionsUnion, AuthActionTypes } from './../actions/auth.actions';\nimport { User } from '../models/user';\n\nexport interface State {\n  loggedIn: boolean;\n  user: User | null;\n}\n\nexport const initialState: State = {\n  loggedIn: false,\n  user: null,\n};\n\nexport function reducer(state = initialState, action: AuthActionsUnion): State {\n  switch (action.type) {\n    case AuthActionTypes.LoginSuccess: {\n      return {\n        ...state,\n        loggedIn: true,\n        user: action.payload.user,\n      };\n    }\n\n    case AuthActionTypes.Logout: {\n      return initialState;\n    }\n\n    default: {\n      return state;\n    }\n  }\n}\n\nexport const getLoggedIn = (state: State) => state.loggedIn;\nexport const getUser = (state: State) => state.user;\n","projects/example-app/src/app/auth/reducers/index.ts":"import {\n  createSelector,\n  createFeatureSelector,\n  ActionReducerMap,\n} from '@ngrx/store';\nimport * as fromRoot from '../../reducers';\nimport * as fromAuth from './auth.reducer';\nimport * as fromLoginPage from './login-page.reducer';\n\nexport interface AuthState {\n  status: fromAuth.State;\n  loginPage: fromLoginPage.State;\n}\n\nexport interface State extends fromRoot.State {\n  auth: AuthState;\n}\n\nexport const reducers: ActionReducerMap<AuthState> = {\n  status: fromAuth.reducer,\n  loginPage: fromLoginPage.reducer,\n};\n\nexport const selectAuthState = createFeatureSelector<State, AuthState>('auth');\n\nexport const selectAuthStatusState = createSelector(\n  selectAuthState,\n  (state: AuthState) => state.status\n);\nexport const getLoggedIn = createSelector(\n  selectAuthStatusState,\n  fromAuth.getLoggedIn\n);\nexport const getUser = createSelector(selectAuthStatusState, fromAuth.getUser);\n\nexport const selectLoginPageState = createSelector(\n  selectAuthState,\n  (state: AuthState) => state.loginPage\n);\nexport const getLoginPageError = createSelector(\n  selectLoginPageState,\n  fromLoginPage.getError\n);\nexport const getLoginPagePending = createSelector(\n  selectLoginPageState,\n  fromLoginPage.getPending\n);\n","projects/example-app/src/app/auth/reducers/login-page.reducer.ts":"import { AuthActionTypes, AuthActionsUnion } from './../actions/auth.actions';\n\nexport interface State {\n  error: string | null;\n  pending: boolean;\n}\n\nexport const initialState: State = {\n  error: null,\n  pending: false,\n};\n\nexport function reducer(state = initialState, action: AuthActionsUnion): State {\n  switch (action.type) {\n    case AuthActionTypes.Login: {\n      return {\n        ...state,\n        error: null,\n        pending: true,\n      };\n    }\n\n    case AuthActionTypes.LoginSuccess: {\n      return {\n        ...state,\n        error: null,\n        pending: false,\n      };\n    }\n\n    case AuthActionTypes.LoginFailure: {\n      return {\n        ...state,\n        error: action.payload,\n        pending: false,\n      };\n    }\n\n    default: {\n      return state;\n    }\n  }\n}\n\nexport const getError = (state: State) => state.error;\nexport const getPending = (state: State) => state.pending;\n","projects/example-app/src/app/auth/services/auth-guard.service.ts":"import { Injectable } from '@angular/core';\nimport { CanActivate } from '@angular/router';\nimport { Store, select } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { map, take } from 'rxjs/operators';\nimport * as AuthActions from '../actions/auth.actions';\nimport * as fromAuth from '../reducers';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthGuard implements CanActivate {\n  constructor(private store: Store<fromAuth.State>) {}\n\n  canActivate(): Observable<boolean> {\n    return this.store.pipe(\n      select(fromAuth.getLoggedIn),\n      map(authed => {\n        if (!authed) {\n          this.store.dispatch(new AuthActions.LoginRedirect());\n          return false;\n        }\n\n        return true;\n      }),\n      take(1)\n    );\n  }\n}\n","projects/example-app/src/app/auth/services/auth.service.ts":"import { Injectable } from '@angular/core';\nimport { Observable, of, throwError } from 'rxjs';\n\nimport { Authenticate, User } from '../models/user';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  constructor() {}\n\n  login({ username, password }: Authenticate): Observable<User> {\n    /**\n     * Simulate a failed login to display the error\n     * message for the login form.\n     */\n    if (username !== 'test') {\n      return throwError('Invalid username or password');\n    }\n\n    return of({ name: 'User' });\n  }\n\n  logout() {\n    return of(true);\n  }\n}\n","projects/example-app/src/app/books/actions/book.actions.ts":"import { Action } from '@ngrx/store';\nimport { Book } from '../models/book';\n\nexport enum BookActionTypes {\n  Search = '[Book] Search',\n  SearchComplete = '[Book] Search Complete',\n  SearchError = '[Book] Search Error',\n  Load = '[Book] Load',\n  Select = '[Book] Select',\n}\n\n/**\n * Every action is comprised of at least a type and an optional\n * payload. Expressing actions as classes enables powerful\n * type checking in reducer functions.\n *\n * See Discriminated Unions: https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions\n */\nexport class Search implements Action {\n  readonly type = BookActionTypes.Search;\n\n  constructor(public payload: string) {}\n}\n\nexport class SearchComplete implements Action {\n  readonly type = BookActionTypes.SearchComplete;\n\n  constructor(public payload: Book[]) {}\n}\n\nexport class SearchError implements Action {\n  readonly type = BookActionTypes.SearchError;\n\n  constructor(public payload: string) {}\n}\n\nexport class Load implements Action {\n  readonly type = BookActionTypes.Load;\n\n  constructor(public payload: Book) {}\n}\n\nexport class Select implements Action {\n  readonly type = BookActionTypes.Select;\n\n  constructor(public payload: string) {}\n}\n\n/**\n * Export a type alias of all actions in this action group\n * so that reducers can easily compose action types\n */\nexport type BookActionsUnion =\n  | Search\n  | SearchComplete\n  | SearchError\n  | Load\n  | Select;\n","projects/example-app/src/app/books/actions/collection.actions.ts":"import { Action } from '@ngrx/store';\nimport { Book } from '../models/book';\n\nexport enum CollectionActionTypes {\n  AddBook = '[Collection] Add Book',\n  AddBookSuccess = '[Collection] Add Book Success',\n  AddBookFail = '[Collection] Add Book Fail',\n  RemoveBook = '[Collection] Remove Book',\n  RemoveBookSuccess = '[Collection] Remove Book Success',\n  RemoveBookFail = '[Collection] Remove Book Fail',\n  Load = '[Collection] Load',\n  LoadSuccess = '[Collection] Load Success',\n  LoadFail = '[Collection] Load Fail',\n}\n\n/**\n * Add Book to Collection Actions\n */\nexport class AddBook implements Action {\n  readonly type = CollectionActionTypes.AddBook;\n\n  constructor(public payload: Book) {}\n}\n\nexport class AddBookSuccess implements Action {\n  readonly type = CollectionActionTypes.AddBookSuccess;\n\n  constructor(public payload: Book) {}\n}\n\nexport class AddBookFail implements Action {\n  readonly type = CollectionActionTypes.AddBookFail;\n\n  constructor(public payload: Book) {}\n}\n\n/**\n * Remove Book from Collection Actions\n */\nexport class RemoveBook implements Action {\n  readonly type = CollectionActionTypes.RemoveBook;\n\n  constructor(public payload: Book) {}\n}\n\nexport class RemoveBookSuccess implements Action {\n  readonly type = CollectionActionTypes.RemoveBookSuccess;\n\n  constructor(public payload: Book) {}\n}\n\nexport class RemoveBookFail implements Action {\n  readonly type = CollectionActionTypes.RemoveBookFail;\n\n  constructor(public payload: Book) {}\n}\n\n/**\n * Load Collection Actions\n */\nexport class Load implements Action {\n  readonly type = CollectionActionTypes.Load;\n}\n\nexport class LoadSuccess implements Action {\n  readonly type = CollectionActionTypes.LoadSuccess;\n\n  constructor(public payload: Book[]) {}\n}\n\nexport class LoadFail implements Action {\n  readonly type = CollectionActionTypes.LoadFail;\n\n  constructor(public payload: any) {}\n}\n\nexport type CollectionActionsUnion =\n  | AddBook\n  | AddBookSuccess\n  | AddBookFail\n  | RemoveBook\n  | RemoveBookSuccess\n  | RemoveBookFail\n  | Load\n  | LoadSuccess\n  | LoadFail;\n","projects/example-app/src/app/books/books-routing.module.ts":"import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { FindBookPageComponent } from './containers/find-book-page.component';\nimport { ViewBookPageComponent } from './containers/view-book-page.component';\nimport { CollectionPageComponent } from './containers/collection-page.component';\nimport { BookExistsGuard } from './guards/book-exists.guard';\n\nexport const routes: Routes = [\n  { path: 'find', component: FindBookPageComponent },\n  {\n    path: ':id',\n    component: ViewBookPageComponent,\n    canActivate: [BookExistsGuard],\n  },\n  { path: '', component: CollectionPageComponent },\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class BooksRoutingModule {}\n","projects/example-app/src/app/books/books.module.ts":"import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\n\nimport { ComponentsModule } from './components';\nimport { BookEffects } from './effects/book.effects';\nimport { CollectionEffects } from './effects/collection.effects';\n\nimport { FindBookPageComponent } from './containers/find-book-page.component';\nimport { ViewBookPageComponent } from './containers/view-book-page.component';\nimport { SelectedBookPageComponent } from './containers/selected-book-page.component';\nimport { CollectionPageComponent } from './containers/collection-page.component';\nimport { MaterialModule } from '../material';\n\nimport { reducers } from './reducers';\nimport { BooksRoutingModule } from './books-routing.module';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    MaterialModule,\n    ComponentsModule,\n    BooksRoutingModule,\n\n    /**\n     * StoreModule.forFeature is used for composing state\n     * from feature modules. These modules can be loaded\n     * eagerly or lazily and will be dynamically added to\n     * the existing state.\n     */\n    StoreModule.forFeature('books', reducers),\n\n    /**\n     * Effects.forFeature is used to register effects\n     * from feature modules. Effects can be loaded\n     * eagerly or lazily and will be started immediately.\n     *\n     * All Effects will only be instantiated once regardless of\n     * whether they are registered once or multiple times.\n     */\n    EffectsModule.forFeature([BookEffects, CollectionEffects]),\n  ],\n  declarations: [\n    FindBookPageComponent,\n    ViewBookPageComponent,\n    SelectedBookPageComponent,\n    CollectionPageComponent,\n  ],\n})\nexport class BooksModule {}\n","projects/example-app/src/app/books/components/book-authors.component.ts":"import { Component, Input } from '@angular/core';\n\nimport { Book } from '../models/book';\n\n@Component({\n  selector: 'bc-book-authors',\n  template: `\n    <h5 mat-subheader>Written By:</h5>\n    <span>\n      {{ authors | bcAddCommas }}\n    </span>\n  `,\n  styles: [\n    `\n      h5 {\n        margin-bottom: 5px;\n      }\n    `,\n  ],\n})\nexport class BookAuthorsComponent {\n  @Input() book: Book;\n\n  get authors() {\n    return this.book.volumeInfo.authors;\n  }\n}\n","projects/example-app/src/app/books/components/book-detail.component.ts":"import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { Book } from '../models/book';\n\n@Component({\n  selector: 'bc-book-detail',\n  template: `\n    <mat-card *ngIf=\"book\">\n      <mat-card-title-group>\n        <mat-card-title>{{ title }}</mat-card-title>\n        <mat-card-subtitle *ngIf=\"subtitle\">{{ subtitle }}</mat-card-subtitle>\n        <img mat-card-sm-image *ngIf=\"thumbnail\" [src]=\"thumbnail\"/>\n      </mat-card-title-group>\n      <mat-card-content>\n        <p [innerHtml]=\"description\"></p>\n      </mat-card-content>\n      <mat-card-footer class=\"footer\">\n        <bc-book-authors [book]=\"book\"></bc-book-authors>\n      </mat-card-footer>\n      <mat-card-actions align=\"start\">\n        <button mat-raised-button color=\"warn\" *ngIf=\"inCollection\" (click)=\"remove.emit(book)\">\n        Remove Book from Collection\n        </button>\n\n        <button mat-raised-button color=\"primary\" *ngIf=\"!inCollection\" (click)=\"add.emit(book)\">\n        Add Book to Collection\n        </button>\n      </mat-card-actions>\n    </mat-card>\n\n  `,\n  styles: [\n    `\n      :host {\n        display: flex;\n        justify-content: center;\n        margin: 75px 0;\n      }\n      mat-card {\n        max-width: 600px;\n      }\n      mat-card-title-group {\n        margin-left: 0;\n      }\n      img {\n        width: 60px;\n        min-width: 60px;\n        margin-left: 5px;\n      }\n      mat-card-content {\n        margin: 15px 0 50px;\n      }\n      mat-card-actions {\n        margin: 25px 0 0 !important;\n      }\n      mat-card-footer {\n        padding: 0 25px 25px;\n        position: relative;\n      }\n    `,\n  ],\n})\nexport class BookDetailComponent {\n  /**\n   * Presentational components receive data through @Input() and communicate events\n   * through @Output() but generally maintain no internal state of their\n   * own. All decisions are delegated to 'container', or 'smart'\n   * components before data updates flow back down.\n   *\n   * More on 'smart' and 'presentational' components: https://gist.github.com/btroncone/a6e4347326749f938510#utilizing-container-components\n   */\n  @Input() book: Book;\n  @Input() inCollection: boolean;\n  @Output() add = new EventEmitter<Book>();\n  @Output() remove = new EventEmitter<Book>();\n\n  /**\n   * Tip: Utilize getters to keep templates clean\n   */\n  get id() {\n    return this.book.id;\n  }\n\n  get title() {\n    return this.book.volumeInfo.title;\n  }\n\n  get subtitle() {\n    return this.book.volumeInfo.subtitle;\n  }\n\n  get description() {\n    return this.book.volumeInfo.description;\n  }\n\n  get thumbnail() {\n    return (\n      this.book.volumeInfo.imageLinks &&\n      this.book.volumeInfo.imageLinks.smallThumbnail &&\n      this.book.volumeInfo.imageLinks.smallThumbnail.replace('http:', '')\n    );\n  }\n}\n","projects/example-app/src/app/books/components/book-preview-list.component.ts":"import { Component, Input } from '@angular/core';\nimport { Book } from '../models/book';\n\n@Component({\n  selector: 'bc-book-preview-list',\n  template: `\n    <bc-book-preview *ngFor=\"let book of books\" [book]=\"book\"></bc-book-preview>\n  `,\n  styles: [\n    `\n      :host {\n        display: flex;\n        flex-wrap: wrap;\n        justify-content: center;\n      }\n    `,\n  ],\n})\nexport class BookPreviewListComponent {\n  @Input() books: Book[];\n}\n","projects/example-app/src/app/books/components/book-preview.component.ts":"import { Component, Input } from '@angular/core';\nimport { Book } from '../models/book';\n\n@Component({\n  selector: 'bc-book-preview',\n  template: `\n    <a [routerLink]=\"['/books', id]\">\n      <mat-card>\n        <mat-card-title-group>\n          <img mat-card-sm-image *ngIf=\"thumbnail\" [src]=\"thumbnail\"/>\n          <mat-card-title>{{ title | bcEllipsis:35 }}</mat-card-title>\n          <mat-card-subtitle *ngIf=\"subtitle\">{{ subtitle | bcEllipsis:40 }}</mat-card-subtitle>\n        </mat-card-title-group>\n        <mat-card-content>\n          <p *ngIf=\"description\">{{ description | bcEllipsis }}</p>\n        </mat-card-content>\n        <mat-card-footer>\n          <bc-book-authors [book]=\"book\"></bc-book-authors>\n        </mat-card-footer>\n      </mat-card>\n    </a>\n  `,\n  styles: [\n    `\n      :host {\n        display: flex;\n      }\n\n      :host a {\n        display: flex;\n      }\n\n      mat-card {\n        width: 400px;\n        margin: 15px;\n        display: flex;\n        flex-flow: column;\n        justify-content: space-between;\n      }\n\n      @media only screen and (max-width: 768px) {\n        mat-card {\n          margin: 15px 0 !important;\n        }\n      }\n      mat-card:hover {\n        box-shadow: 3px 3px 16px -2px rgba(0, 0, 0, 0.5);\n      }\n      mat-card-title {\n        margin-right: 10px;\n      }\n      mat-card-title-group {\n        margin: 0;\n      }\n      a {\n        color: inherit;\n        text-decoration: none;\n      }\n      img {\n        width: 60px;\n        min-width: 60px;\n        margin-left: 5px;\n      }\n      mat-card-content {\n        margin-top: 15px;\n        margin: 15px 0 0;\n      }\n      span {\n        display: inline-block;\n        font-size: 13px;\n      }\n      mat-card-footer {\n        padding: 0 25px 25px;\n      }\n    `,\n  ],\n})\nexport class BookPreviewComponent {\n  @Input() book: Book;\n\n  get id() {\n    return this.book.id;\n  }\n\n  get title() {\n    return this.book.volumeInfo.title;\n  }\n\n  get subtitle() {\n    return this.book.volumeInfo.subtitle;\n  }\n\n  get description() {\n    return this.book.volumeInfo.description;\n  }\n\n  get thumbnail(): string | boolean {\n    if (this.book.volumeInfo.imageLinks) {\n      return this.book.volumeInfo.imageLinks.smallThumbnail.replace(\n        'http:',\n        ''\n      );\n    }\n\n    return false;\n  }\n}\n","projects/example-app/src/app/books/components/book-search.component.ts":"import { Component, Output, Input, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'bc-book-search',\n  template: `\n    <mat-card>\n      <mat-card-title>Find a Book</mat-card-title>\n      <mat-card-content>\n        <mat-form-field>\n          <input matInput placeholder=\"Search for a book\" [value]=\"query\" (keyup)=\"search.emit($event.target.value)\">\n        </mat-form-field>\n        <mat-spinner [class.show]=\"searching\" [diameter]=\"30\" [strokeWidth]=\"3\"></mat-spinner>\n      </mat-card-content>\n      <mat-card-footer><span *ngIf=\"error\">{{error}}</span></mat-card-footer>\n    </mat-card>\n  `,\n  styles: [\n    `\n      mat-card-title,\n      mat-card-content,\n      mat-card-footer {\n        display: flex;\n        justify-content: center;\n      }\n\n      mat-card-footer {\n        color: #ff0000;\n        padding: 5px 0;\n      }\n\n      .mat-form-field {\n        min-width: 300px;\n        margin-right: 10px; // Make room for the spinner\n      }\n\n      .mat-spinner {\n        position: relative;\n        top: 10px;\n        left: 10px;\n        visibility: hidden;\n      }\n\n      .mat-spinner.show {\n        visibility: visible;\n      }\n    `,\n  ],\n})\nexport class BookSearchComponent {\n  @Input() query = '';\n  @Input() searching = false;\n  @Input() error = '';\n  @Output() search = new EventEmitter<string>();\n}\n","projects/example-app/src/app/books/components/index.ts":"import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { RouterModule } from '@angular/router';\n\nimport { BookAuthorsComponent } from './book-authors.component';\nimport { BookDetailComponent } from './book-detail.component';\nimport { BookPreviewComponent } from './book-preview.component';\nimport { BookPreviewListComponent } from './book-preview-list.component';\nimport { BookSearchComponent } from './book-search.component';\n\nimport { PipesModule } from '../../shared/pipes';\nimport { MaterialModule } from '../../material';\n\nexport const COMPONENTS = [\n  BookAuthorsComponent,\n  BookDetailComponent,\n  BookPreviewComponent,\n  BookPreviewListComponent,\n  BookSearchComponent,\n];\n\n@NgModule({\n  imports: [\n    CommonModule,\n    ReactiveFormsModule,\n    MaterialModule,\n    RouterModule,\n    PipesModule,\n  ],\n  declarations: COMPONENTS,\n  exports: COMPONENTS,\n})\nexport class ComponentsModule {}\n","projects/example-app/src/app/books/containers/collection-page.component.ts":"import { ChangeDetectionStrategy, Component, OnInit } from '@angular/core';\nimport { select, Store } from '@ngrx/store';\nimport { Observable } from 'rxjs';\n\nimport * as CollectionActions from '../actions/collection.actions';\nimport { Book } from '../models/book';\nimport * as fromBooks from '../reducers';\n\n@Component({\n  selector: 'bc-collection-page',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <mat-card>\n      <mat-card-title>My Collection</mat-card-title>\n    </mat-card>\n\n    <bc-book-preview-list [books]=\"books$ | async\"></bc-book-preview-list>\n  `,\n  /**\n   * Container components are permitted to have just enough styles\n   * to bring the view together. If the number of styles grow,\n   * consider breaking them out into presentational\n   * components.\n   */\n  styles: [\n    `\n      mat-card-title {\n        display: flex;\n        justify-content: center;\n      }\n    `,\n  ],\n})\nexport class CollectionPageComponent implements OnInit {\n  books$: Observable<Book[]>;\n\n  constructor(private store: Store<fromBooks.State>) {\n    this.books$ = store.pipe(select(fromBooks.getBookCollection));\n  }\n\n  ngOnInit() {\n    this.store.dispatch(new CollectionActions.Load());\n  }\n}\n","projects/example-app/src/app/books/containers/find-book-page.component.ts":"import { ChangeDetectionStrategy, Component } from '@angular/core';\nimport { select, Store } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nimport * as BookActions from '../actions/book.actions';\nimport { Book } from '../models/book';\nimport * as fromBooks from '../reducers';\n\n@Component({\n  selector: 'bc-find-book-page',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <bc-book-search\n      [query]=\"searchQuery$ | async\"\n      [searching]=\"loading$ | async\"\n      [error]=\"error$ | async\"\n      (search)=\"search($event)\">\n    </bc-book-search>\n    <bc-book-preview-list\n      [books]=\"books$ | async\">\n    </bc-book-preview-list>\n  `,\n})\nexport class FindBookPageComponent {\n  searchQuery$: Observable<string>;\n  books$: Observable<Book[]>;\n  loading$: Observable<boolean>;\n  error$: Observable<string>;\n\n  constructor(private store: Store<fromBooks.State>) {\n    this.searchQuery$ = store.pipe(\n      select(fromBooks.getSearchQuery),\n      take(1)\n    );\n    this.books$ = store.pipe(select(fromBooks.getSearchResults));\n    this.loading$ = store.pipe(select(fromBooks.getSearchLoading));\n    this.error$ = store.pipe(select(fromBooks.getSearchError));\n  }\n\n  search(query: string) {\n    this.store.dispatch(new BookActions.Search(query));\n  }\n}\n","projects/example-app/src/app/books/containers/selected-book-page.component.ts":"import { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { Store, select } from '@ngrx/store';\nimport { Observable } from 'rxjs';\n\nimport * as fromBooks from '../reducers';\nimport * as CollectionActions from '../actions/collection.actions';\nimport { Book } from '../models/book';\n\n@Component({\n  selector: 'bc-selected-book-page',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <bc-book-detail\n      [book]=\"book$ | async\"\n      [inCollection]=\"isSelectedBookInCollection$ | async\"\n      (add)=\"addToCollection($event)\"\n      (remove)=\"removeFromCollection($event)\">\n    </bc-book-detail>\n  `,\n})\nexport class SelectedBookPageComponent {\n  book$: Observable<Book>;\n  isSelectedBookInCollection$: Observable<boolean>;\n\n  constructor(private store: Store<fromBooks.State>) {\n    this.book$ = store.pipe(select(fromBooks.getSelectedBook)) as Observable<\n      Book\n    >;\n    this.isSelectedBookInCollection$ = store.pipe(\n      select(fromBooks.isSelectedBookInCollection)\n    );\n  }\n\n  addToCollection(book: Book) {\n    this.store.dispatch(new CollectionActions.AddBook(book));\n  }\n\n  removeFromCollection(book: Book) {\n    this.store.dispatch(new CollectionActions.RemoveBook(book));\n  }\n}\n","projects/example-app/src/app/books/containers/view-book-page.component.ts":"import { Component, OnDestroy, ChangeDetectionStrategy } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { Store } from '@ngrx/store';\nimport { Subscription } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport * as fromBooks from '../reducers';\nimport * as BookActions from '../actions/book.actions';\n\n/**\n * Note: Container components are also reusable. Whether or not\n * a component is a presentation component or a container\n * component is an implementation detail.\n *\n * The View Book Page's responsibility is to map router params\n * to a 'Select' book action. Actually showing the selected\n * book remains a responsibility of the\n * SelectedBookPageComponent\n */\n@Component({\n  selector: 'bc-view-book-page',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <bc-selected-book-page></bc-selected-book-page>\n  `,\n})\nexport class ViewBookPageComponent implements OnDestroy {\n  actionsSubscription: Subscription;\n\n  constructor(store: Store<fromBooks.State>, route: ActivatedRoute) {\n    this.actionsSubscription = route.params\n      .pipe(map(params => new BookActions.Select(params.id)))\n      .subscribe(store);\n  }\n\n  ngOnDestroy() {\n    this.actionsSubscription.unsubscribe();\n  }\n}\n","projects/example-app/src/app/books/effects/book.effects.ts":"import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { Actions, Effect, ofType } from '@ngrx/effects';\nimport { Action } from '@ngrx/store';\nimport { asyncScheduler, EMPTY as empty, Observable, of } from 'rxjs';\nimport {\n  catchError,\n  debounceTime,\n  map,\n  skip,\n  switchMap,\n  takeUntil,\n} from 'rxjs/operators';\n\nimport { GoogleBooksService } from '../../core/services/google-books.service';\nimport {\n  BookActionTypes,\n  Search,\n  SearchComplete,\n  SearchError,\n} from '../actions/book.actions';\nimport { Book } from '../models/book';\n\n/**\n * Effects offer a way to isolate and easily test side-effects within your\n * application.\n *\n * If you are unfamiliar with the operators being used in these examples, please\n * check out the sources below:\n *\n * Official Docs: http://reactivex.io/rxjs/manual/overview.html#categories-of-operators\n * RxJS 5 Operators By Example: https://gist.github.com/btroncone/d6cf141d6f2c00dc6b35\n */\n\n@Injectable()\nexport class BookEffects {\n  @Effect()\n  search$ = ({ debounce = 300, scheduler = asyncScheduler } = {}): Observable<\n    Action\n  > =>\n    this.actions$.pipe(\n      ofType<Search>(BookActionTypes.Search),\n      debounceTime(debounce, scheduler),\n      map(action => action.payload),\n      switchMap(query => {\n        if (query === '') {\n          return empty;\n        }\n\n        const nextSearch$ = this.actions$.pipe(\n          ofType(BookActionTypes.Search),\n          skip(1)\n        );\n\n        return this.googleBooks.searchBooks(query).pipe(\n          takeUntil(nextSearch$),\n          map((books: Book[]) => new SearchComplete(books)),\n          catchError(err => of(new SearchError(err)))\n        );\n      })\n    );\n\n  constructor(\n    private actions$: Actions,\n    private googleBooks: GoogleBooksService\n  ) {}\n}\n","projects/example-app/src/app/books/effects/collection.effects.ts":"import { Injectable } from '@angular/core';\nimport { Database } from '@ngrx/db';\nimport { Actions, Effect, ofType } from '@ngrx/effects';\nimport { Action } from '@ngrx/store';\nimport { defer, Observable, of } from 'rxjs';\nimport { catchError, map, mergeMap, switchMap, toArray } from 'rxjs/operators';\n\nimport { Book } from '../models/book';\nimport {\n  AddBook,\n  AddBookFail,\n  AddBookSuccess,\n  CollectionActionTypes,\n  LoadFail,\n  LoadSuccess,\n  RemoveBook,\n  RemoveBookFail,\n  RemoveBookSuccess,\n} from './../actions/collection.actions';\n\n@Injectable()\nexport class CollectionEffects {\n  /**\n   * This effect does not yield any actions back to the store. Set\n   * `dispatch` to false to hint to @ngrx/effects that it should\n   * ignore any elements of this effect stream.\n   *\n   * The `defer` observable accepts an observable factory function\n   * that is called when the observable is subscribed to.\n   * Wrapping the database open call in `defer` makes\n   * effect easier to test.\n   */\n  @Effect({ dispatch: false })\n  openDB$: Observable<any> = defer(() => {\n    return this.db.open('books_app');\n  });\n\n  @Effect()\n  loadCollection$: Observable<Action> = this.actions$.pipe(\n    ofType(CollectionActionTypes.Load),\n    switchMap(() =>\n      this.db.query('books').pipe(\n        toArray(),\n        map((books: Book[]) => new LoadSuccess(books)),\n        catchError(error => of(new LoadFail(error)))\n      )\n    )\n  );\n\n  @Effect()\n  addBookToCollection$: Observable<Action> = this.actions$.pipe(\n    ofType<AddBook>(CollectionActionTypes.AddBook),\n    map(action => action.payload),\n    mergeMap(book =>\n      this.db.insert('books', [book]).pipe(\n        map(() => new AddBookSuccess(book)),\n        catchError(() => of(new AddBookFail(book)))\n      )\n    )\n  );\n\n  @Effect()\n  removeBookFromCollection$: Observable<Action> = this.actions$.pipe(\n    ofType<RemoveBook>(CollectionActionTypes.RemoveBook),\n    map(action => action.payload),\n    mergeMap(book =>\n      this.db.executeWrite('books', 'delete', [book.id]).pipe(\n        map(() => new RemoveBookSuccess(book)),\n        catchError(() => of(new RemoveBookFail(book)))\n      )\n    )\n  );\n\n  constructor(private actions$: Actions, private db: Database) {}\n}\n","projects/example-app/src/app/books/guards/book-exists.guard.ts":"import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivate, Router } from '@angular/router';\nimport { select, Store } from '@ngrx/store';\nimport { Observable, of } from 'rxjs';\nimport { catchError, filter, map, switchMap, take, tap } from 'rxjs/operators';\n\nimport { GoogleBooksService } from '../../core/services/google-books.service';\nimport * as BookActions from '../actions/book.actions';\nimport * as fromBooks from '../reducers';\n\n/**\n * Guards are hooks into the route resolution process, providing an opportunity\n * to inform the router's navigation process whether the route should continue\n * to activate this route. Guards must return an observable of true or false.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BookExistsGuard implements CanActivate {\n  constructor(\n    private store: Store<fromBooks.State>,\n    private googleBooks: GoogleBooksService,\n    private router: Router\n  ) {}\n\n  /**\n   * This method creates an observable that waits for the `loaded` property\n   * of the collection state to turn `true`, emitting one time once loading\n   * has finished.\n   */\n  waitForCollectionToLoad(): Observable<boolean> {\n    return this.store.pipe(\n      select(fromBooks.getCollectionLoaded),\n      filter(loaded => loaded),\n      take(1)\n    );\n  }\n\n  /**\n   * This method checks if a book with the given ID is already registered\n   * in the Store\n   */\n  hasBookInStore(id: string): Observable<boolean> {\n    return this.store.pipe(\n      select(fromBooks.getBookEntities),\n      map(entities => !!entities[id]),\n      take(1)\n    );\n  }\n\n  /**\n   * This method loads a book with the given ID from the API and caches\n   * it in the store, returning `true` or `false` if it was found.\n   */\n  hasBookInApi(id: string): Observable<boolean> {\n    return this.googleBooks.retrieveBook(id).pipe(\n      map(bookEntity => new BookActions.Load(bookEntity)),\n      tap((action: BookActions.Load) => this.store.dispatch(action)),\n      map(book => !!book),\n      catchError(() => {\n        this.router.navigate(['/404']);\n        return of(false);\n      })\n    );\n  }\n\n  /**\n   * `hasBook` composes `hasBookInStore` and `hasBookInApi`. It first checks\n   * if the book is in store, and if not it then checks if it is in the\n   * API.\n   */\n  hasBook(id: string): Observable<boolean> {\n    return this.hasBookInStore(id).pipe(\n      switchMap(inStore => {\n        if (inStore) {\n          return of(inStore);\n        }\n\n        return this.hasBookInApi(id);\n      })\n    );\n  }\n\n  /**\n   * This is the actual method the router will call when our guard is run.\n   *\n   * Our guard waits for the collection to load, then it checks if we need\n   * to request a book from the API or if we already have it in our cache.\n   * If it finds it in the cache or in the API, it returns an Observable\n   * of `true` and the route is rendered successfully.\n   *\n   * If it was unable to find it in our cache or in the API, this guard\n   * will return an Observable of `false`, causing the router to move\n   * on to the next candidate route. In this case, it will move on\n   * to the 404 page.\n   */\n  canActivate(route: ActivatedRouteSnapshot): Observable<boolean> {\n    return this.waitForCollectionToLoad().pipe(\n      switchMap(() => this.hasBook(route.params['id']))\n    );\n  }\n}\n","projects/example-app/src/app/books/models/book.ts":"export interface Book {\n  id: string;\n  volumeInfo: {\n    title: string;\n    subtitle: string;\n    authors: string[];\n    publisher: string;\n    publishDate: string;\n    description: string;\n    averageRating: number;\n    ratingsCount: number;\n    imageLinks: {\n      thumbnail: string;\n      smallThumbnail: string;\n    };\n  };\n}\n\nexport function generateMockBook(): Book {\n  return {\n    id: '1',\n    volumeInfo: {\n      title: 'title',\n      subtitle: 'subtitle',\n      authors: ['author'],\n      publisher: 'publisher',\n      publishDate: '',\n      description: 'description',\n      averageRating: 3,\n      ratingsCount: 5,\n      imageLinks: {\n        thumbnail: 'string',\n        smallThumbnail: 'string',\n      },\n    },\n  };\n}\n","projects/example-app/src/app/books/reducers/books.reducer.ts":"import { createEntityAdapter, EntityAdapter, EntityState } from '@ngrx/entity';\nimport { Book } from '../models/book';\nimport { BookActionsUnion, BookActionTypes } from '../actions/book.actions';\nimport {\n  CollectionActionsUnion,\n  CollectionActionTypes,\n} from '../actions/collection.actions';\n\n/**\n * @ngrx/entity provides a predefined interface for handling\n * a structured dictionary of records. This interface\n * includes an array of ids, and a dictionary of the provided\n * model type by id. This interface is extended to include\n * any additional interface properties.\n */\nexport interface State extends EntityState<Book> {\n  selectedBookId: string | null;\n}\n\n/**\n * createEntityAdapter creates an object of many helper\n * functions for single or multiple operations\n * against the dictionary of records. The configuration\n * object takes a record id selector function and\n * a sortComparer option which is set to a compare\n * function if the records are to be sorted.\n */\nexport const adapter: EntityAdapter<Book> = createEntityAdapter<Book>({\n  selectId: (book: Book) => book.id,\n  sortComparer: false,\n});\n\n/**\n * getInitialState returns the default initial state\n * for the generated entity state. Initial state\n * additional properties can also be defined.\n */\nexport const initialState: State = adapter.getInitialState({\n  selectedBookId: null,\n});\n\nexport function reducer(\n  state = initialState,\n  action: BookActionsUnion | CollectionActionsUnion\n): State {\n  switch (action.type) {\n    case BookActionTypes.SearchComplete:\n    case CollectionActionTypes.LoadSuccess: {\n      /**\n       * The addMany function provided by the created adapter\n       * adds many records to the entity dictionary\n       * and returns a new state including those records. If\n       * the collection is to be sorted, the adapter will\n       * sort each record upon entry into the sorted array.\n       */\n      return adapter.addMany(action.payload, state);\n    }\n\n    case BookActionTypes.Load: {\n      /**\n       * The addOne function provided by the created adapter\n       * adds one record to the entity dictionary\n       * and returns a new state including that records if it doesn't\n       * exist already. If the collection is to be sorted, the adapter will\n       * insert the new record into the sorted array.\n       */\n      return adapter.addOne(action.payload, state);\n    }\n\n    case BookActionTypes.Select: {\n      return {\n        ...state,\n        selectedBookId: action.payload,\n      };\n    }\n\n    default: {\n      return state;\n    }\n  }\n}\n\n/**\n * Because the data structure is defined within the reducer it is optimal to\n * locate our selector functions at this level. If store is to be thought of\n * as a database, and reducers the tables, selectors can be considered the\n * queries into said database. Remember to keep your selectors small and\n * focused so they can be combined and composed to fit each particular\n * use-case.\n */\n\nexport const getSelectedId = (state: State) => state.selectedBookId;\n","projects/example-app/src/app/books/reducers/collection.reducer.ts":"import {\n  CollectionActionTypes,\n  CollectionActionsUnion,\n} from './../actions/collection.actions';\n\nexport interface State {\n  loaded: boolean;\n  loading: boolean;\n  ids: string[];\n}\n\nconst initialState: State = {\n  loaded: false,\n  loading: false,\n  ids: [],\n};\n\nexport function reducer(\n  state = initialState,\n  action: CollectionActionsUnion\n): State {\n  switch (action.type) {\n    case CollectionActionTypes.Load: {\n      return {\n        ...state,\n        loading: true,\n      };\n    }\n\n    case CollectionActionTypes.LoadSuccess: {\n      return {\n        loaded: true,\n        loading: false,\n        ids: action.payload.map(book => book.id),\n      };\n    }\n\n    case CollectionActionTypes.AddBookSuccess:\n    case CollectionActionTypes.RemoveBookFail: {\n      if (state.ids.indexOf(action.payload.id) > -1) {\n        return state;\n      }\n\n      return {\n        ...state,\n        ids: [...state.ids, action.payload.id],\n      };\n    }\n\n    case CollectionActionTypes.RemoveBookSuccess:\n    case CollectionActionTypes.AddBookFail: {\n      return {\n        ...state,\n        ids: state.ids.filter(id => id !== action.payload.id),\n      };\n    }\n\n    default: {\n      return state;\n    }\n  }\n}\n\nexport const getLoaded = (state: State) => state.loaded;\n\nexport const getLoading = (state: State) => state.loading;\n\nexport const getIds = (state: State) => state.ids;\n","projects/example-app/src/app/books/reducers/index.ts":"import {\n  createSelector,\n  createFeatureSelector,\n  ActionReducerMap,\n} from '@ngrx/store';\nimport * as fromSearch from './search.reducer';\nimport * as fromBooks from './books.reducer';\nimport * as fromCollection from './collection.reducer';\nimport * as fromRoot from '../../reducers';\n\nexport interface BooksState {\n  search: fromSearch.State;\n  books: fromBooks.State;\n  collection: fromCollection.State;\n}\n\nexport interface State extends fromRoot.State {\n  books: BooksState;\n}\n\nexport const reducers: ActionReducerMap<BooksState> = {\n  search: fromSearch.reducer,\n  books: fromBooks.reducer,\n  collection: fromCollection.reducer,\n};\n\n/**\n * A selector function is a map function factory. We pass it parameters and it\n * returns a function that maps from the larger state tree into a smaller\n * piece of state. This selector simply selects the `books` state.\n *\n * Selectors are used with the `select` operator.\n *\n * ```ts\n * class MyComponent {\n *   constructor(state$: Observable<State>) {\n *     this.booksState$ = state$.pipe(select(getBooksState));\n *   }\n * }\n * ```\n */\n\n/**\n * The createFeatureSelector function selects a piece of state from the root of the state object.\n * This is used for selecting feature states that are loaded eagerly or lazily.\n */\nexport const getBooksState = createFeatureSelector<State, BooksState>('books');\n\n/**\n * Every reducer module exports selector functions, however child reducers\n * have no knowledge of the overall state tree. To make them usable, we\n * need to make new selectors that wrap them.\n *\n * The createSelector function creates very efficient selectors that are memoized and\n * only recompute when arguments change. The created selectors can also be composed\n * together to select different pieces of state.\n */\nexport const getBookEntitiesState = createSelector(\n  getBooksState,\n  state => state.books\n);\n\nexport const getSelectedBookId = createSelector(\n  getBookEntitiesState,\n  fromBooks.getSelectedId\n);\n\n/**\n * Adapters created with @ngrx/entity generate\n * commonly used selector functions including\n * getting all ids in the record set, a dictionary\n * of the records by id, an array of records and\n * the total number of records. This reduces boilerplate\n * in selecting records from the entity state.\n */\nexport const {\n  selectIds: getBookIds,\n  selectEntities: getBookEntities,\n  selectAll: getAllBooks,\n  selectTotal: getTotalBooks,\n} = fromBooks.adapter.getSelectors(getBookEntitiesState);\n\nexport const getSelectedBook = createSelector(\n  getBookEntities,\n  getSelectedBookId,\n  (entities, selectedId) => {\n    return selectedId && entities[selectedId];\n  }\n);\n\n/**\n * Just like with the books selectors, we also have to compose the search\n * reducer's and collection reducer's selectors.\n */\nexport const getSearchState = createSelector(\n  getBooksState,\n  (state: BooksState) => state.search\n);\n\nexport const getSearchBookIds = createSelector(\n  getSearchState,\n  fromSearch.getIds\n);\nexport const getSearchQuery = createSelector(\n  getSearchState,\n  fromSearch.getQuery\n);\nexport const getSearchLoading = createSelector(\n  getSearchState,\n  fromSearch.getLoading\n);\nexport const getSearchError = createSelector(\n  getSearchState,\n  fromSearch.getError\n);\n\n/**\n * Some selector functions create joins across parts of state. This selector\n * composes the search result IDs to return an array of books in the store.\n */\nexport const getSearchResults = createSelector(\n  getBookEntities,\n  getSearchBookIds,\n  (books, searchIds) => {\n    return searchIds.map(id => books[id]);\n  }\n);\n\nexport const getCollectionState = createSelector(\n  getBooksState,\n  (state: BooksState) => state.collection\n);\n\nexport const getCollectionLoaded = createSelector(\n  getCollectionState,\n  fromCollection.getLoaded\n);\nexport const getCollectionLoading = createSelector(\n  getCollectionState,\n  fromCollection.getLoading\n);\nexport const getCollectionBookIds = createSelector(\n  getCollectionState,\n  fromCollection.getIds\n);\n\nexport const getBookCollection = createSelector(\n  getBookEntities,\n  getCollectionBookIds,\n  (entities, ids) => {\n    return ids.map(id => entities[id]);\n  }\n);\n\nexport const isSelectedBookInCollection = createSelector(\n  getCollectionBookIds,\n  getSelectedBookId,\n  (ids, selected) => {\n    return ids.indexOf(selected) > -1;\n  }\n);\n","projects/example-app/src/app/books/reducers/search.reducer.ts":"import { BookActionTypes, BookActionsUnion } from '../actions/book.actions';\n\nexport interface State {\n  ids: string[];\n  loading: boolean;\n  error: string;\n  query: string;\n}\n\nconst initialState: State = {\n  ids: [],\n  loading: false,\n  error: '',\n  query: '',\n};\n\nexport function reducer(state = initialState, action: BookActionsUnion): State {\n  switch (action.type) {\n    case BookActionTypes.Search: {\n      const query = action.payload;\n\n      if (query === '') {\n        return {\n          ids: [],\n          loading: false,\n          error: '',\n          query,\n        };\n      }\n\n      return {\n        ...state,\n        loading: true,\n        error: '',\n        query,\n      };\n    }\n\n    case BookActionTypes.SearchComplete: {\n      return {\n        ids: action.payload.map(book => book.id),\n        loading: false,\n        error: '',\n        query: state.query,\n      };\n    }\n\n    case BookActionTypes.SearchError: {\n      return {\n        ...state,\n        loading: false,\n        error: action.payload,\n      };\n    }\n\n    default: {\n      return state;\n    }\n  }\n}\n\nexport const getIds = (state: State) => state.ids;\n\nexport const getQuery = (state: State) => state.query;\n\nexport const getLoading = (state: State) => state.loading;\n\nexport const getError = (state: State) => state.error;\n","projects/example-app/src/app/core/actions/layout.actions.ts":"import { Action } from '@ngrx/store';\n\nexport enum LayoutActionTypes {\n  OpenSidenav = '[Layout] Open Sidenav',\n  CloseSidenav = '[Layout] Close Sidenav',\n}\n\nexport class OpenSidenav implements Action {\n  readonly type = LayoutActionTypes.OpenSidenav;\n}\n\nexport class CloseSidenav implements Action {\n  readonly type = LayoutActionTypes.CloseSidenav;\n}\n\nexport type LayoutActionsUnion = OpenSidenav | CloseSidenav;\n","projects/example-app/src/app/core/components/layout.component.ts":"import { Component } from '@angular/core';\n\n@Component({\n  selector: 'bc-layout',\n  template: `\n    <mat-sidenav-container fullscreen>\n\n      <ng-content></ng-content>\n\n    </mat-sidenav-container>\n  `,\n  styles: [\n    `\n      mat-sidenav-container {\n        background: rgba(0, 0, 0, 0.03);\n      }\n\n      *,\n      /deep/ * {\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n      }\n    `,\n  ],\n})\nexport class LayoutComponent {}\n","projects/example-app/src/app/core/components/nav-item.component.ts":"import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'bc-nav-item',\n  template: `\n    <a mat-list-item [routerLink]=\"routerLink\" (click)=\"navigate.emit()\">\n      <mat-icon mat-list-icon>{{ icon }}</mat-icon>\n      <span mat-line><ng-content></ng-content></span>\n      <span mat-line class=\"secondary\">{{ hint }}</span>\n    </a>\n  `,\n  styles: [\n    `\n      .secondary {\n        color: rgba(0, 0, 0, 0.54);\n      }\n    `,\n  ],\n})\nexport class NavItemComponent {\n  @Input() icon = '';\n  @Input() hint = '';\n  @Input() routerLink: string | any[] = '/';\n  @Output() navigate = new EventEmitter();\n}\n","projects/example-app/src/app/core/components/sidenav.component.ts":"import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'bc-sidenav',\n  template: `\n    <mat-sidenav #sidenav [opened]=\"open\" (keydown.escape)=\"sidenav.close()\" (closedStart)=\"closeMenu.emit()\" disableClose>\n      <mat-nav-list>\n        <ng-content></ng-content>\n      </mat-nav-list>\n    </mat-sidenav>\n  `,\n  styles: [\n    `\n      mat-sidenav {\n        width: 300px;\n      }\n    `,\n  ],\n})\nexport class SidenavComponent {\n  @Input() open = false;\n  @Output() closeMenu = new EventEmitter();\n}\n","projects/example-app/src/app/core/components/toolbar.component.ts":"import { Component, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'bc-toolbar',\n  template: `\n    <mat-toolbar color=\"primary\">\n      <button mat-icon-button (click)=\"openMenu.emit()\">\n        <mat-icon>menu</mat-icon>\n      </button>\n      <ng-content></ng-content>\n    </mat-toolbar>\n  `,\n})\nexport class ToolbarComponent {\n  @Output() openMenu = new EventEmitter();\n}\n","projects/example-app/src/app/core/containers/app.component.ts":"import { ChangeDetectionStrategy, Component } from '@angular/core';\nimport { select, Store } from '@ngrx/store';\nimport { Observable } from 'rxjs';\n\nimport * as AuthActions from '../../auth/actions/auth.actions';\nimport * as fromAuth from '../../auth/reducers';\nimport * as fromRoot from '../../reducers';\nimport * as LayoutActions from '../actions/layout.actions';\n\n@Component({\n  selector: 'bc-app',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <bc-layout>\n      <bc-sidenav [open]=\"showSidenav$ | async\" (closeMenu)=\"closeSidenav()\">\n        <bc-nav-item (navigate)=\"closeSidenav()\" *ngIf=\"loggedIn$ | async\" routerLink=\"/\" icon=\"book\" hint=\"View your book collection\">\n          My Collection\n        </bc-nav-item>\n        <bc-nav-item (navigate)=\"closeSidenav()\" *ngIf=\"loggedIn$ | async\" routerLink=\"/books/find\" icon=\"search\" hint=\"Find your next book!\">\n          Browse Books\n        </bc-nav-item>\n        <bc-nav-item (navigate)=\"closeSidenav()\" *ngIf=\"!(loggedIn$ | async)\">\n          Sign In\n        </bc-nav-item>\n        <bc-nav-item (navigate)=\"logout()\" *ngIf=\"loggedIn$ | async\">\n          Sign Out\n        </bc-nav-item>\n      </bc-sidenav>\n      <bc-toolbar (openMenu)=\"openSidenav()\">\n        Book Collection\n      </bc-toolbar>\n\n      <router-outlet></router-outlet>\n    </bc-layout>\n  `,\n})\nexport class AppComponent {\n  showSidenav$: Observable<boolean>;\n  loggedIn$: Observable<boolean>;\n\n  constructor(private store: Store<fromRoot.State>) {\n    /**\n     * Selectors can be applied with the `select` operator which passes the state\n     * tree to the provided selector\n     */\n    this.showSidenav$ = this.store.pipe(select(fromRoot.getShowSidenav));\n    this.loggedIn$ = this.store.pipe(select(fromAuth.getLoggedIn));\n  }\n\n  closeSidenav() {\n    /**\n     * All state updates are handled through dispatched actions in 'container'\n     * components. This provides a clear, reproducible history of state\n     * updates and user interaction through the life of our\n     * application.\n     */\n    this.store.dispatch(new LayoutActions.CloseSidenav());\n  }\n\n  openSidenav() {\n    this.store.dispatch(new LayoutActions.OpenSidenav());\n  }\n\n  logout() {\n    this.closeSidenav();\n\n    this.store.dispatch(new AuthActions.Logout());\n  }\n}\n","projects/example-app/src/app/core/containers/not-found-page.component.ts":"import { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'bc-not-found-page',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <mat-card>\n      <mat-card-title>404: Not Found</mat-card-title>\n      <mat-card-content>\n        <p>Hey! It looks like this page doesn't exist yet.</p>\n      </mat-card-content>\n      <mat-card-actions>\n        <button mat-raised-button color=\"primary\" routerLink=\"/\">Take Me Home</button>\n      </mat-card-actions>\n    </mat-card>\n  `,\n  styles: [\n    `\n      :host {\n        text-align: center;\n      }\n    `,\n  ],\n})\nexport class NotFoundPageComponent {}\n","projects/example-app/src/app/core/core.module.ts":"import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\n\nimport { AppComponent } from './containers/app.component';\nimport { NotFoundPageComponent } from './containers/not-found-page.component';\nimport { LayoutComponent } from './components/layout.component';\nimport { NavItemComponent } from './components/nav-item.component';\nimport { SidenavComponent } from './components/sidenav.component';\nimport { ToolbarComponent } from './components/toolbar.component';\nimport { MaterialModule } from '../material';\n\nexport const COMPONENTS = [\n  AppComponent,\n  NotFoundPageComponent,\n  LayoutComponent,\n  NavItemComponent,\n  SidenavComponent,\n  ToolbarComponent,\n];\n\n@NgModule({\n  imports: [CommonModule, RouterModule, MaterialModule],\n  declarations: COMPONENTS,\n  exports: COMPONENTS,\n})\nexport class CoreModule {}\n","projects/example-app/src/app/core/reducers/layout.reducer.ts":"import {\n  LayoutActionTypes,\n  LayoutActionsUnion,\n} from '../actions/layout.actions';\n\nexport interface State {\n  showSidenav: boolean;\n}\n\nconst initialState: State = {\n  showSidenav: false,\n};\n\nexport function reducer(\n  state: State = initialState,\n  action: LayoutActionsUnion\n): State {\n  switch (action.type) {\n    case LayoutActionTypes.CloseSidenav:\n      return {\n        showSidenav: false,\n      };\n\n    case LayoutActionTypes.OpenSidenav:\n      return {\n        showSidenav: true,\n      };\n\n    default:\n      return state;\n  }\n}\n\nexport const getShowSidenav = (state: State) => state.showSidenav;\n","projects/example-app/src/app/core/services/google-books.service.ts":"import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { Book } from '../../books/models/book';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class GoogleBooksService {\n  private API_PATH = 'https://www.googleapis.com/books/v1/volumes';\n\n  constructor(private http: HttpClient) {}\n\n  searchBooks(queryTitle: string): Observable<Book[]> {\n    return this.http\n      .get<{ items: Book[] }>(`${this.API_PATH}?q=${queryTitle}`)\n      .pipe(map(books => books.items || []));\n  }\n\n  retrieveBook(volumeId: string): Observable<Book> {\n    return this.http.get<Book>(`${this.API_PATH}/${volumeId}`);\n  }\n}\n","projects/example-app/src/app/db.ts":"import { DBSchema } from '@ngrx/db';\n\n/**\n * ngrx/db uses a simple schema config object to initialize stores in IndexedDB.\n */\nexport const schema: DBSchema = {\n  version: 1,\n  name: 'books_app',\n  stores: {\n    books: {\n      autoIncrement: true,\n      primaryKey: 'id',\n    },\n  },\n};\n","projects/example-app/src/app/index.ts":"export * from './app.module';\n","projects/example-app/src/app/material/index.ts":"export * from './material.module';\n","projects/example-app/src/app/material/material.module.ts":"import { NgModule } from '@angular/core';\n\nimport {\n  MatInputModule,\n  MatCardModule,\n  MatButtonModule,\n  MatSidenavModule,\n  MatListModule,\n  MatIconModule,\n  MatToolbarModule,\n  MatProgressSpinnerModule,\n} from '@angular/material';\n\n@NgModule({\n  imports: [\n    MatInputModule,\n    MatCardModule,\n    MatButtonModule,\n    MatSidenavModule,\n    MatListModule,\n    MatIconModule,\n    MatToolbarModule,\n    MatProgressSpinnerModule,\n  ],\n  exports: [\n    MatInputModule,\n    MatCardModule,\n    MatButtonModule,\n    MatSidenavModule,\n    MatListModule,\n    MatIconModule,\n    MatToolbarModule,\n    MatProgressSpinnerModule,\n  ],\n})\nexport class MaterialModule {}\n","projects/example-app/src/app/reducers/index.ts":"import {\n  ActionReducerMap,\n  createSelector,\n  createFeatureSelector,\n  ActionReducer,\n  MetaReducer,\n} from '@ngrx/store';\nimport { environment } from '../../environments/environment';\nimport * as fromRouter from '@ngrx/router-store';\n\n/**\n * storeFreeze prevents state from being mutated. When mutation occurs, an\n * exception will be thrown. This is useful during development mode to\n * ensure that none of the reducers accidentally mutates the state.\n */\nimport { storeFreeze } from 'ngrx-store-freeze';\n\n/**\n * Every reducer module's default export is the reducer function itself. In\n * addition, each module should export a type or interface that describes\n * the state of the reducer plus any selector functions. The `* as`\n * notation packages up all of the exports into a single object.\n */\n\nimport * as fromLayout from '../core/reducers/layout.reducer';\n\n/**\n * As mentioned, we treat each reducer like a table in a database. This means\n * our top level state interface is just a map of keys to inner state types.\n */\nexport interface State {\n  layout: fromLayout.State;\n  router: fromRouter.RouterReducerState;\n}\n\n/**\n * Our state is composed of a map of action reducer functions.\n * These reducer functions are called with each dispatched action\n * and the current or initial state and return a new immutable state.\n */\nexport const reducers: ActionReducerMap<State> = {\n  layout: fromLayout.reducer,\n  router: fromRouter.routerReducer,\n};\n\n// console.log all actions\nexport function logger(reducer: ActionReducer<State>): ActionReducer<State> {\n  return function(state: State, action: any): State {\n    console.log('state', state);\n    console.log('action', action);\n\n    return reducer(state, action);\n  };\n}\n\n/**\n * By default, @ngrx/store uses combineReducers with the reducer map to compose\n * the root meta-reducer. To add more meta-reducers, provide an array of meta-reducers\n * that will be composed to form the root meta-reducer.\n */\nexport const metaReducers: MetaReducer<State>[] = !environment.production\n  ? [logger, storeFreeze]\n  : [];\n\n/**\n * Layout Reducers\n */\nexport const getLayoutState = createFeatureSelector<State, fromLayout.State>(\n  'layout'\n);\n\nexport const getShowSidenav = createSelector(\n  getLayoutState,\n  fromLayout.getShowSidenav\n);\n","projects/example-app/src/app/shared/pipes/add-commas.pipe.ts":"import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({ name: 'bcAddCommas' })\nexport class AddCommasPipe implements PipeTransform {\n  transform(authors: null | string[]) {\n    if (!authors) {\n      return 'Author Unknown';\n    }\n\n    switch (authors.length) {\n      case 0:\n        return 'Author Unknown';\n      case 1:\n        return authors[0];\n      case 2:\n        return authors.join(' and ');\n      default:\n        const last = authors[authors.length - 1];\n        const remaining = authors.slice(0, -1);\n        return `${remaining.join(', ')}, and ${last}`;\n    }\n  }\n}\n","projects/example-app/src/app/shared/pipes/ellipsis.pipe.ts":"import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({ name: 'bcEllipsis' })\nexport class EllipsisPipe implements PipeTransform {\n  transform(str: string, strLength: number = 250) {\n    const withoutHtml = str.replace(/(<([^>]+)>)/gi, '');\n\n    if (str.length >= strLength) {\n      return `${withoutHtml.slice(0, strLength)}...`;\n    }\n\n    return withoutHtml;\n  }\n}\n","projects/example-app/src/app/shared/pipes/index.ts":"import { NgModule } from '@angular/core';\n\nimport { AddCommasPipe } from './add-commas.pipe';\nimport { EllipsisPipe } from './ellipsis.pipe';\n\nexport const PIPES = [AddCommasPipe, EllipsisPipe];\n\n@NgModule({\n  declarations: PIPES,\n  exports: PIPES,\n})\nexport class PipesModule {}\n","projects/example-app/src/environments/environment.prod.ts":"export const environment = {\n  production: true,\n};\n","projects/example-app/src/environments/environment.ts":"// The file contents for the current environment will overwrite these during build.\n// The build system defaults to the dev environment which uses `environment.ts`, but if you do\n// `ng build --env=prod` then `environment.prod.ts` will be used instead.\n// The list of which env maps to which file can be found in `angular-cli.json`.\n\nexport const environment = {\n  production: false,\n};\n","projects/example-app/src/favicon.ico":"\u0000\u0000\u0001\u0000\u0002\u0000\u0010\u0010\u0000\u0000\u0000\u0000 \u0000h\u0004\u0000\u0000&\u0000\u0000\u0000  \u0000\u0000\u0000\u0000 \u0000\u0010\u0000\u0000\u0004\u0000\u0000(\u0000\u0000\u0000\u0010\u0000\u0000\u0000 \u0000\u0000\u0000\u0001\u0000 \u0000\u0000\u0000\u0000\u0000@\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0001\u0001\u0001\u0001\u000171U610-2.;\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u00017197171710-0-1-3/#\u0001\u0001\u0001\u0001\u0001\u000171!71717171710-0-0-0-1-3/\u000f\u0001\u0001\u000171U71OIVQ8271710-0-0-URKH0-2.=\u0001\u00017171mh71710-0-[X0-1.{\u0001\u00017171C=71710-0-850-0-\u0001\u00017171710-0-1-\u0001\u0001717171QL?<0-0-0-\u0001\u000171717171;5:70-0-0-0-\u000171#71717171d_}yIG0-0-0-0-4/\u000f71M71717171710-0-0-0-0-3/A71k7171717171zvVS0-0-0-0-0-2.e71}7171717171930-0-0-0-0-0-1.{71A717171717171db0-0-0-0-0-1-0-E\u0001\u000171)71717171=70-0-0-0-1-3//\u0001\u0001\u0001\u0001\u0001\u0001\u000171A71610-0-3.9\u0001\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000(\u0000\u0000\u0000 \u0000\u0000\u0000@\u0000\u0000\u0000\u0001\u0000 \u0000\u0000\u0000\u0000\u0000\u0010\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171612.3/?\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171_7171710-0-2.3/\u001f\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171;71717171710-0-0-0-3.4/\u000b\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171\u001d717171717171710-0-0-0-0-1.3/\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171\t7171717171717171710-0-0-0-0-0-0-1.3/_\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171717171717171717171710-0-0-0-0-0-0-0-0-2.3/;\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171Y7171717171717171717171710-0-0-0-0-0-0-0-0-0-0-2.3/\u001d\u0001\u0001\u0001\u0001\u0001\u0001717171XSwrvrvr<771717171710-0-0-0-0-0-wu~|~|NK0-0-2.\u0001\u0001\u0001\u0001\u0001\u0001717171UP{w71717171710-0-0-0-0-YWDB0-0-1.\u0001\u0001\u0001\u0001\u000171\u001b7171717171717171710-0-0-0-0-0-0-0-1.\u0001\u0001\u0001\u0001\u000171O71717171hcSN717171710-0-0-0-B?PM0-0-0-0-50\u0003\u0001\u0001\u0001\u000171}7171717171717171710-0-0-0-0-0-0-0-0-3/3\u0001\u0001\u0001\u0001717171717171~{][0-0-0-0-0-3/i\u0001\u0001\u0001\u0001717171717171;50-0-0-0-0-0-3/\u0001\u0001\u0001\u000171717171717171mk0-0-0-0-0-0-2.\u0001\u0001\u0001\u000171717171717171D>ieiedbdb1.0-0-0-0-0-0-2.\u0001\u0001\u0001\u0001717171717171717171710-0-|z0-0-0-0-0-0-0-2.\u0001\u0001\u0001\u00017171717171717171RLJD710-XU520-0-0-0-0-0-0-1.\u0001\u0001\u000171+717171717171717171710-0-0-0-0-0-0-0-0-0-50\u0005\u0001\u000171]717171717171717171ea:4QO:70-0-0-0-0-0-0-0-0-4/5\u0001\u00017171717171717171717171wr0-0-0-0-0-0-0-0-0-0-3/k\u0001\u00017171717171717171717171zvC@0-0-0-0-0-0-0-0-0-0-3/\u0001\u00017171717171717171717171:40-0-0-0-0-0-0-0-0-0-0-2.\u0001\u0001717171717171717171717171MK0-0-0-0-0-0-0-0-0-0-0-2.\u0001\u0001717171717171717171717171B<0-0-0-0-0-0-0-0-0-0-0-0-2.\u0001\u000171717171717171717171717171[Y0-0-0-0-0-0-0-0-0-0-0-0-1.\u0001\u000171717171717171717171717171OJ0-0-0-0-0-0-0-0-0-0-0-0-0-0-\u0001\u000171\u000571y717171717171717171717171jg0-0-0-0-0-0-0-0-0-0-0-2.3/4/\u0015\u0001\u0001\u0001\u0001\u000171\u001371717171717171717171PK1.0-0-0-0-0-0-0-0-2.3/3/\u001d\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171)71717171717171710-0-0-0-0-0-1.3/4/'\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171C71717171710-0-0-1.3.3/1\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u000171a71611.2.3/=\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000","projects/example-app/src/index.html":"<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Book Collection</title>\n  <base href=\"/\">\n\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n  <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\">\n</head>\n<body>\n  <bc-app>Loading...</bc-app>\n</body>\n</html>\n","projects/example-app/src/main.ts":"import './polyfills.ts';\n\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { enableProdMode } from '@angular/core';\nimport { environment } from './environments/environment';\nimport { AppModule } from './app/app.module';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n","projects/example-app/src/polyfills.ts":"// This file includes polyfills needed by Angular and is loaded before\n// the app. You can add your own extra polyfills to this file.\nimport 'core-js/es6/symbol';\nimport 'core-js/es6/object';\nimport 'core-js/es6/function';\nimport 'core-js/es6/parse-int';\nimport 'core-js/es6/parse-float';\nimport 'core-js/es6/number';\nimport 'core-js/es6/math';\nimport 'core-js/es6/string';\nimport 'core-js/es6/date';\nimport 'core-js/es6/array';\nimport 'core-js/es6/regexp';\nimport 'core-js/es6/map';\nimport 'core-js/es6/set';\nimport 'core-js/es6/reflect';\n\nimport 'core-js/es7/reflect';\nimport 'zone.js/dist/zone';\n\nimport 'hammerjs';\n","projects/example-app/src/setup-jest.ts":"import 'jest-preset-angular';\n(global as any)['CSS'] = null;\n\n/**\n * ISSUE: https://github.com/angular/material2/issues/7101\n * Workaround for JSDOM missing transform property\n */\nObject.defineProperty(document.body.style, 'transform', {\n  value: () => {\n    return {\n      enumerable: true,\n      configurable: true,\n    };\n  },\n});\n","projects/example-app/src/styles.css":"/* You can add global styles to this file, and also import other style files */\n@import \"~@angular/material/prebuilt-themes/deeppurple-amber.css\";\n\n* {\n  box-sizing: border-box;\n}\n\nhtml {\n  -webkit-font-smoothing: antialiased;\n  -ms-overflow-style: none;\n  overflow: auto;\n}\n\n.mat-progress-spinner svg {\n  width: 30px !important;\n  height: 30px !important;\n}\n","projects/example-app/src/test.ts":"// This file is required by karma.conf.js and loads recursively all the .spec and framework files\n\nimport 'zone.js/dist/long-stack-trace-zone';\nimport 'zone.js/dist/proxy.js';\nimport 'zone.js/dist/sync-test';\nimport 'zone.js/dist/jasmine-patch';\nimport 'zone.js/dist/async-test';\nimport 'zone.js/dist/fake-async-test';\nimport { getTestBed } from '@angular/core/testing';\nimport {\n  BrowserDynamicTestingModule,\n  platformBrowserDynamicTesting,\n} from '@angular/platform-browser-dynamic/testing';\n\n// fixes typing errors in Atom editor\nimport {} from 'jasmine';\n\n// Unfortunately there's no typing for the `__karma__` variable. Just declare it as any.\ndeclare var __karma__: any;\ndeclare var require: any;\n\n// Prevent Karma from running prematurely.\n__karma__.loaded = function() {};\n\n// First, initialize the Angular testing environment.\ngetTestBed().initTestEnvironment(\n  BrowserDynamicTestingModule,\n  platformBrowserDynamicTesting()\n);\n// Then we find all the tests.\nconst context = require.context('./', true, /\\.spec\\.ts$/);\n// And load the modules.\ncontext.keys().map(context);\n// Finally, start Karma to run the tests.\n__karma__.start();\n","projects/example-app/tsconfig.app.json":"{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"declaration\": false,\n    \"moduleResolution\": \"node\",\n    \"emitDecoratorMetadata\": true,\n    \"experimentalDecorators\": true,\n    \"lib\": [\"es2017\", \"dom\"],\n    \"outDir\": \"../out-tsc/app\",\n    \"target\": \"es5\",\n    \"module\": \"es2015\",\n    \"types\": [],\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@ngrx/effects\": [\"../../modules/effects\"],\n      \"@ngrx/store\": [\"../../modules/store\"],\n      \"@ngrx/store-devtools\": [\"../../modules/store-devtools\"],\n      \"@ngrx/router-store\": [\"../../modules/router-store\"],\n      \"@ngrx/entity\": [\"../../modules/entity\"],\n      \"@ngrx/schematics\": [\"../../modules/schematics\"]\n    }\n  },\n  \"exclude\": [\n    \"../../node_modules\",\n    \"test.ts\",\n    \"**/*.spec.ts\",\n    \"**/setup-jest.ts\"\n  ]\n}\n","projects/example-app/tsconfig.spec.json":"{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"declaration\": false,\n    \"moduleResolution\": \"node\",\n    \"emitDecoratorMetadata\": true,\n    \"experimentalDecorators\": true,\n    \"lib\": [\"es2017\", \"dom\"],\n    \"outDir\": \"../out-tsc/spec\",\n    \"module\": \"commonjs\",\n    \"target\": \"es6\",\n    \"types\": [\"jasmine\", \"node\"],\n    \"baseUrl\": \".\",\n    \"rootDir\": \"./\"\n  },\n  \"files\": [\"test.ts\", \"polyfills.ts\"],\n  \"include\": [\"**/*.spec.ts\"]\n}\n","projects/example-app/tslint.json":"{\n  \"rules\": {\n    \"class-name\": true,\n    \"no-duplicate-variable\": true,\n    \"no-eval\": false,\n    \"no-internal-module\": true,\n    \"no-var-keyword\": true,\n    \"triple-equals\": [false, \"allow-null-check\"],\n    \"variable-name\": [true, \"ban-keywords\", \"allow-leading-underscore\"]\n  }\n}\n"},
        title: 'NgRx Example App',
        description: 'NgRx example application with common patterns and best practices',
        template: 'angular-cli',
        tags: ['angular', 'ngrx', 'redux', 'example'],
        dependencies: {"@angular/animations":"^6.1.0","@angular/bazel":"^6.1.0","@angular/cdk":"^6.4.2","@angular/cli":"^6.1.2","@angular/common":"^6.1.0","@angular/compiler":"^6.1.0","@angular/compiler-cli":"^6.1.0","@angular/core":"^6.1.0","@angular/forms":"^6.1.0","@angular/http":"^6.1.0","@angular/material":"^6.4.2","@angular/platform-browser":"^6.1.0","@angular/platform-browser-dynamic":"^6.1.0","@angular/platform-server":"^6.1.0","@angular/router":"^6.1.0","@ngrx/db":"^2.2.0-beta.0","core-js":"^2.5.4","hammerjs":"^2.0.8","ngrx-store-freeze":"^0.2.2","opencollective":"^1.0.3","rxjs":"^6.2.2","rxjs-compat":"^6.2.2","zone.js":"^0.8.26","@ngrx/effects":"6.1.0","@ngrx/entity":"6.1.0","@ngrx/router-store":"6.1.0","@ngrx/schematics":"6.1.0","@ngrx/store":"6.1.0","@ngrx/store-devtools":"6.1.0"}
      };

      StackBlitzSDK.openProject(project, { newWindow: false });
    </script>
    </body>
    </html>
  